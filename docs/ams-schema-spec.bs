<pre class='metadata'>
Title: Amsterdam Schema Specificatie
Shortname: ams-schema-spec
Revision: 2.4.0
Status: LS
URL: https://schemas.data.amsterdam.nl/docs/ams-schema-spec.html
Repository: Amsterdam/amsterdam-schema
Editor: Team Data Diensten van het Dataplatform onder de Directie Digitale Voorzieningen, Gemeente Amsterdam, https://data.amsterdam.nl/
Abstract: Het Amsterdam Schema is een op JSON Schema’s gebaseerde standaard (ondersteund door het Amsterdam Meta Schema)
    om datasets in een machineleesbaar format te beschrijven en op generieke wijze te verwerken en te ontsluiten.
Markup Shorthands: css no, markdown yes
Indent: 4
Default highlight: js
Logo: https://api.data.amsterdam.nl/api/gemeente_Amsterdam_logo.svg
Favicon: https://data.amsterdam.nl/favicon.png
Boilerplate: copyright no, footer no
Max ToC Depth: 2
Text Macro: DCAT <a data-link-type=biblio data-lt="vocab-dcat-3" data-biblio-type=informative>DCAT</a>
Text Macro: DCATURL https://www.w3.org/TR/vocab-dcat-3/
Text Macro: BP <blockquote class="best-practice"> **Best Practice**
Text Macro: BPE </blockquote>
Text Macro: CONST *constant*
Text Macro: HIDELINESEXAMPLE <div class="example hide-lines" onClick="this.classList.toggle('hide-lines');this.classList.toggle('unhide-lines');">
Text Macro: COMPAREA <div class="a" onscroll="let sibling =this.nextElementSibling; sibling.scrollTop=this.scrollTop;sibling.scrollLeft=this.scrollLeft;">
Text Macro: COMPAREB <div class="b" onscroll="let sibling =this.previousElementSibling; sibling.scrollTop=this.scrollTop;sibling.scrollLeft=this.scrollLeft;">
Text Macro: END </div>
</pre>

Advisement: De meest recente aanpassing aan deze specificatie is:<br/> [[#lastchange]]

<!--
████ ██    ██ ████████ ████████   ███████
 ██  ███   ██    ██    ██     ██ ██     ██
 ██  ████  ██    ██    ██     ██ ██     ██
 ██  ██ ██ ██    ██    ████████  ██     ██
 ██  ██  ████    ██    ██   ██   ██     ██
 ██  ██   ███    ██    ██    ██  ██     ██
████ ██    ██    ██    ██     ██  ███████
-->
Introductie {#intro}
====================
> **Doelstelling**<br/>
    Alle data van gemeente Amsterdam binnen één machine verwerkbaar universeel format beschrijven,
    zodat het geautomatiseerd verwerkt en ontsloten kan worden.
    En zo vanuit de [tada principes](https://www.amsterdam.nl/innovatie/digitalisering-technologie/tada-principes/) bij dragen aan een transparante, datagedreven organisatie.

Het Amsterdam Schema is een standaard voor het beschrijven van datasets.
De structuur van de data kan samen met meta-informatie in een machineverwerkbaar format vastgelegd worden.
Zo kunnen datasets automatisch verwerkt en ontsloten worden.

Dit document legt uit hoe een dataset volgens de Amsterdam Schema-standaard beschreven wordt.

<div class=example>
    Neem bijvoorbeeld een dataset over monumenten. <br/>
    Van deze dataset kan worden vastgelegd:
    * dat het de  object typen *standbeelden* en *gebouwen* heeft,
    * dat gebouwen de eigenschappen *bouwjaar* (getal), *type* (enum), *functie* (tekst) hebben.
    * en wat *type* en *functie* precies betekent.
</div>

Note: Een actueel overzicht van gepubliceerde Amsterdam Schema's is te vinden op [GitHub](https://github.com/Amsterdam/amsterdam-schema/tree/master/datasets).

Note: Amsterdam Schema is gebaseerd op [JSON Schema's](https://json-schema.org).


Overzicht {#overzicht}
--------------------------------------------------
Een dataset wordt beschreven in één of meer JSON bestanden.

Binnen deze bestanden bestaan de volgende niveaus:
: [[#datasets| dataset]]
:: Een samenhangende collectie van data met één beheerder of beherende instantie.
    Zoals bedoeld in [[vocab-dcat-3#dcat-scope|DCAT]].
    Op dit niveau wordt voornamelijk meta-informatie over de herkomst en aard van de data meegegeven, zoals de naam, beschrijving, licentie en publicatiedatum.
    Een dataset bevat minstens één versie.
: [[#dataset-version|versie]]
:: Beschrijft een versie van een dataset. Bevat een set van velden die beschrijft welke eigenschappen deze versie heeft en bevat minstens één tabel.
: [[#tables|tabel]]
:: Beschrijft een type object dat in de dataset voorkomt. Bevat een set van velden die beschrijft welke eigenschappen datarijen in deze tabel moeten of mogen bezitten.
: [[#fields|veld]]
:: Beschrijft de eigenschappen van rijen in een tabel, zoals de naam en het datatype van een eigenschap. Vergelijkbaar met de kolommen van een database.

Note: Binnen Amsterdam Schema wordt de Data Catalog Vocabulary (hierna [DCAT]) standaard gebruikt. DCAT is een naamgevingsstandaard voor het publiceren van datacatalogi op het web.


<!--
████████     ███    ████████    ███     ██████  ████████ ████████
██     ██   ██ ██      ██      ██ ██   ██    ██ ██          ██
██     ██  ██   ██     ██     ██   ██  ██       ██          ██
██     ██ ██     ██    ██    ██     ██  ██████  ██████      ██
██     ██ █████████    ██    █████████       ██ ██          ██
██     ██ ██     ██    ██    ██     ██ ██    ██ ██          ██
████████  ██     ██    ██    ██     ██  ██████  ████████    ██
-->
Dataset {#datasets}
========================================================
Met een dataset wordt een dataset zoals gedefinieerd in [DCAT] bedoeld. [DCAT] definieert een dataset als volgt:
> **Dataset**
  A collection of data, published or curated by a single agent or identifiable community.
  The notion of dataset in DCAT is broad and inclusive, with the intention of accommodating resource types arising from all communities.
  Data comes in many forms including numbers, text, pixels, imagery, sound and other multi-media, and potentially other types,
  any of which might be collected into a dataset. (From [[vocab-dcat-3#dcat-scope]])

Verplichte attributen {#dataset-mandatory-fields}
-------------------------------------------------------
Een <dfn dfn export>dataset</dfn> binnen Amsterdam Schema bestaat uit een JSON bestand met in ieder geval de volgende velden:
<table dfn-type="attribute" dfn-for=dataset export class="dfn-table">
    <tr><td><dfn>id</dfn>       <td> {{id-type|identifier}} <td> Unieke identifier voor deze dataset. Moet voldoen aan [[#naamgeving]]. Conform \[DCAT § resource_identifier](https://www.w3.org/TR/vocab-dcat-3/#Property:resource_identifier).
    <tr><td><dfn>type</dfn>     <td> {{schema-type}}        <td> Type van dit bestand, in dit geval `"dataset"`.
    <tr><td><dfn>auth</dfn>                 <td> string | array | [[#scope-refs|scope-ref]] <td> geautoriseerde [=scope|scope(s)=]. Voor openbare data: `"OPENBAAR"`. zie [[#autorisatie]]
    <tr><td><dfn>authorizationGrantor</dfn> <td> string     <td> E-mailadres van de afdeling verantwoordelijk voor autorisatie op deze dataset. Dit is meestal de bronhouder. Aan dit adres worden authorisatie verzoeken gericht.
    <tr><td><dfn>creator</dfn>              <td> string     <td> Team, afdeling of organisatie die de data produceert, meestal de bronhouder. Wanneer data van meerdere bronhouders wordt gecomineerd, wordt hier de opdrachtgever bedoelt.
    <tr><td><dfn>owner</dfn>                <td> string     <td> Juridisch eigenaar van de data. Bijvoorbeeld `"Gemeente Amsterdam, Directie Wonen"` of `"Centraal Bureau voor de Statistiek"`  Default: `"Gemeente Amsterdam"`
    <tr><td><dfn>publisher</dfn>            <td> string | [[#publisher-refs|publisher-ref]] <td> Het team verantwoordelijk voor het technisch ontsluiten van de data. Meestal het datateam. Conform \[DCAT § resource_publisher]([DCATURL]#Property:resource_publisher)
    <tr><td><dfn>defaultVersion</dfn>       <td> {{major-version-string}} <td> De default versie van de dataset die gebruikt wordt in de doelsystemen.
    <tr><td><dfn>versions</dfn>             <td> object
        <td> [=versie|Versies=] in deze dataset. Moet minimaal 1 element bevatten.
            <details>
                <summary>Valide elementen</summary>
                * een [=versie=] json object
            </details>
</table>

Advisement: Let op: Zie [[#naamgeving]] voor de eisen waaraan {{dataset/id}} moet voldoen.

Note: Als een versie van een dataset nog niet klaar is voor publicatie, zet de {{versie/status}} dan op `"niet_beschikbaar"`. Zo wordt de dataset nog niet zichtbaar in doelsystemen.

<div class=example>
    Een minimale dataset definitie. De 'title' en 'description' velden zijn niet verplicht,
    maar het is best practice ze toe te voegen.
    <pre class=include-code>
        path: examples/datasets/minimaal/dataset.json
        highlight: json
    </pre>
</div>

[BP]
    Zet bij datasets met meer dan één tabel alle tabellen in hun een eigen bestand
    en gebruik [=tabelreferenties=]. Dit komt de leesbaarheid ten goede en maakt versionering mogelijk.
[BPE]

Optionele attributen {#dataset-optional-fields}
--------------------------------------------------------
Naast bovenstaande verplichte attributen mag een [=dataset=] ook de volgende eigenschappen bevatten.
<table dfn-type="attribute" dfn-for=dataset export class="dfn-table">
    <tr><td><dfn>contactPoint</dfn>         <td> {{contact}}
        <td> Contactgegevens van de persoon of afdeling verantwoordelijk voor eerstelijns ondersteuning bij deze dataset. Hier kunnen mensen met vragen over de dataset terecht. (Deze gegevens worden publiek zichtbaar.) Wanneer dit veld niet is gegeven, is impliciet de default waarde van toepassing. Default: `{"name": "Datapunt", "email": "datapunt@amsterdam.nl"}`
    <tr><td><dfn>title</dfn>            <td> string     <td> zie [[#omschrijving]] [DCAT § Property:resource_title]([DCATURL]#Property:resource_title)
    <tr><td><dfn>description</dfn>      <td> string     <td> zie [[#omschrijving]] [DCAT § Property:resource_description]([DCATURL]#Property:resource_description)
    <tr><td><dfn>provenance</dfn>       <td> string     <td> zie [[#provenance]]
    <tr><td><dfn>reasonsNonPublic</dfn>  <td> array({{nonPubReason}})
        <td> een of meer gronden voor het niet openbaar maken van data obv uitzonderingen in Hoofdstuk 5 van de [[Woo]].
             Verplicht wanneer {{dataset/auth}} niet gelijk is aan `"OPENBAAR"`) zie [[#autorisatie]]
    <tr><td><dfn>homepage</dfn>         <td> {{uri-type|uri}}    <td> Homepage van de dataset
    <tr><td><dfn>crs</dfn>
        <td> enum(string)
        <td> Coordinate reference System
            <details open>
                <summary>Opties</summary>
                    * "EPSG:28992"
                    * "EPSG:4326"
                    * "EPSG:7415"
            </details>
            Dit veld is **verplicht** voor datasets waarvan één of meerdere tabellen één of meer [[#geometry]] velden bevatten en waarvan de crs niet al in de tabel of veld gedefinieerd is.
            Zie [[SDW-BP#CRS-background]] voor meer informatie.
</table>

[BP]
    Voeg altijd op zijn minst een title en description toe.
[BPE]

### DCAT velden ### {#dataset-dcat-fields}
Het is mogelijk op dataset niveau extra eigenschappen met meta-gegevens mee te geven.
Dit kan indien gewenst worden gebruikt om automatisch een [DCAT] catalogus te genereren.
De volgende velden zijn toegestaan:
<table dfn-type="attribute" dfn-for=dataset export class="dfn-table">
    <tr><td><dfn>language</dfn>             <td> string <td> Taal van de dataset volgens [ISO 639-1](http://id.loc.gov/vocabulary/iso639-1.html) of [ISO 639-2](http://id.loc.gov/vocabulary/iso639-2.html) Conform \[DCAT § resource_language](https://www.w3.org/TR/vocab-dcat-3/#Property:resource_language)
    <tr><td><dfn>dateCreated</dfn>          <td> {{date-time}} <td> Datum van publicatie. Conform \[DCAT § resource_release_date]([DCATURL]#Property:resource_release_date)
    <tr><td><dfn>dateModified</dfn>         <td> {{date-time}} <td> Meest recente datum waarop de dataset is aangepast. Conform \[DCAT § resource_update_date]([DCATURL]#Property:resource_update_date)
    <tr><td><dfn>accrualPeriodicity</dfn>   <td> string <td> Frequentie waarmee de dataset gepubliceerd wordt. Conform \[DCAT § dataset_frequency]([DCATURL]#Property:dataset_frequency)
    <tr><td><dfn>spatialDescription</dfn>   <td> string <td>
    <tr><td><dfn>spatialCoordinates</dfn>   <td> Geometry <td> Een [GeoJSON](https://geojson.org/) geometry
    <tr><td><dfn>theme</dfn>                <td> array (string) <td> Array van themas Conform \[DCAT § resource_theme]([DCATURL]#Property:resource_theme)
    <tr><td><dfn>hasBeginning</dfn>         <td> {{date-time}} <td>
    <tr><td><dfn>hasEnd</dfn>               <td> {{date-time}} <td>
    <tr><td><dfn>objective</dfn>            <td> string <td>
    <tr><td><dfn>temporalUnit</dfn>         <td> string <td>  Eenheid van temporaliteit Conform? \[DCAT § dataset_temporal_resolution]([DCATURL]#Property:dataset_temporal_resolution)
    <tr><td><dfn>spatial</dfn>              <td> string <td>
    <tr><td><dfn>legalBasis</dfn>           <td> string <td>
    <tr><td><dfn>keywords</dfn>             <td> array (string) <td> Array van keywords Conform \[DCAT § resource_keyword]([DCATURL]#Property:resource_keyword)
    <tr><td><dfn>license</dfn>              <td> string <td> Licentie Conform \[DCAT § resource_license]([DCATURL]#Property:resource_license)
</table>

Note: De intentie is dat alle relevante [DCAT] velden te modelleren zijn. Wanneer velden ontbreken
    die wel in de [DCAT] zijn opgenomen, zullen deze worden toegevoegd.

Issue: Niet alle DCAT velden zijn gemodelleerd. Daarnaast zijn komt van sommige velden de naamgeving niet overeen met de DCAT spec.

Issue: Sommige velden missen een beschrijving

Tabelreferenties {#table-refs}
----------------------------------------------------------
Tabelreferenties zijn verwijzingen naar JSON-bestanden waarin een [=tabel=] gedefinieerd wordt.
Dit maakt het mogelijk om elke tabel in een dataset in een eigen bestand te definiëren.
Tabelreferenties zijn gebaseerd op [[JSON-SCHEMA#ref]].

Een <dfn export>tabelreferentie</dfn> is een JSON object met in ieder geval de volgende attributen:
<table dfn-type="attribute" dfn-for=table-ref export class="dfn-table">
    <tr><td><dfn>id</dfn>   <td> {{id-type|identifier}} <td> Binnen deze dataset unieke identifier voor deze tabel. Zou gelijk moeten zijn aan tabel.id. Moet voldoen aan [[#naamgeving]].
    <tr><td><dfn lt="ref">$ref</dfn> <td> {{uri-reference}}
        <td> URI-Reference naar JSON bestand met de [=tabel=] definitie zonder de bestandsextensie.
            De reference is altijd relatief aan de locatie van het dataset bestand.
        </td>
</table>

Elk tabeldefinitiebestand **zou** samen met andere versies van dezelfde tabel
in een eigen map moeten staan waarvan de naam gelijk is aan de tabel id.
De bestandsnaam van een tabeldefinitiebestand **zou** gelijk moeten zijn aan het major versienummer van de tabel
voorafgegaan door 'v' met een '.json' extensie.
Het pad gezien vanuit de locatie van het datasetbestand **zou** dus de volgende vorm moeten hebben:
    ```bash
    <tabelid>/v<major>.json
    ```

Advisement: Van deze bestandsnaam en padstructuur moet niet worden afgeweken behalve als daar een zwaarwegende reden voor is.

Publisherreferenties {#publisher-refs}
----------------------------------------------------------
Publisherreferenties zijn verwijzingen naar JSON-bestanden waarin een [=publisher=] gedefinieerd wordt.
Publisherreferenties zijn gebaseerd op [[JSON-SCHEMA#ref]].

Een <dfn export>publisherreferentie</dfn> is een JSON object met 1 attribuut:
<table dfn-type="attribute" dfn-for=publisher-ref export class="dfn-table">
    <tr><td><dfn lt="ref">$ref</dfn> <td> {{uri-reference}}
        <td> URI-Reference naar JSON bestand met de [=publisher=] definitie zonder de bestandsextensie.
            De reference is altijd van de vorm `publishers/<BESTANDSNAAM>`. Bijvoorbeeld: `publishers/SOEB`
        </td>
</table>

Scopereferenties {#scope-refs}
----------------------------------------------------------
Scopereferenties zijn verwijzingen naar JSON-bestanden waarin een [=scope=] gedefinieerd wordt.
Scopereferenties zijn gebaseerd op [[JSON-SCHEMA#ref]].

Een <dfn export>scopereferentie</dfn> is een JSON object met 1 attribuut:
<table dfn-type="attribute" dfn-for=scope-ref export class="dfn-table">
    <tr><td><dfn lt="ref">$ref</dfn> <td> {{uri-reference}}
        <td> URI-Reference naar JSON bestand met de [=scope=] definitie zonder de bestandsextensie.
            De reference is altijd van de vorm `scopes/<BESTANDSNAAM>`. Bijvoorbeeld: `scopes/BENK/LEVEL-X`
        </td>
</table>

Versionering {#dataset-versioning}
------------------------------------------------------

Een dataset kan geversioneerd worden zodat er tegelijkertijd meerdere versies van een dataproduct actief kunnen zijn
en er een overgangsperiode kan ontstaan waarin een oudere versie van een dataset ondersteund blijft totdat alle
afnemers overgestapt zijn op een nieuwe versie van de dataset. Zie [[#dataset-version|versie]] voor de implementatie in het
Amsterdam Schema.

Note: Deze manier van versioneren is geïntroduceerd in V3 van het Amsterdam schema.

Note: Er kan momenteel slechts één versie van de dataset zijn met de status 'beschikbaar'. Dit dient
overeen te komen met de waarde in {{dataset/defaultVersion}}.

Een [=versie=] wordt in het schema aangeduid door middel van een {{major-version-string|major versie}} van het
{{version-string|versienummer}} van een dataset. Iedere versie van een dataset bevat een of meerdere tabellen die
ook geversioneerd kunnen zijn. De versienummers van een dataset gebruiken semantic versioning. Dit betekend dat de
versienummers betekenis hebben. Zo valt met een blik op het versienummer iets te zeggen over de aard van de gedane
aanpassing.

Het versie nummer bestaat uit 3 getallen gescheiden door punten `MAJOR.MINOR.PATCH`:
    * **major** versie bumps vinden plaats bij veranderingen die *niet backwards compatible* zijn.
        Dit zijn alle aanpassingen waarbij het kan voorkomen een afnemer de data volgens het nieuwe schema niet meer
        kan consumeren.
    * **minor** versies zijn *volledig backwards compatible* en vereisen dus geen aanpassingen voor een afnemer.
    * **patch** versies bevatten *alleen metadata aanpassingen*, waarbij de datastructuur gelijk blijft.

Note: We behandelen aanpassingen als breaking changes vanuit het oogpunt van de afnemer. Voorheen was dit vanuit het
 oogpunt van de leverancier.

**Metadata aanpassingen** zijn veranderingen aan een of meer van de volgende attributen:
    * "title" op [=dataset=], [=tabel=] of [=veld=] niveau
    * "description" op [=dataset=], [=tabel=] of [=veld=] niveau
    * "shortname" op [=dataset=], [=tabel=] of [=veld=] niveau
    * "{{unit}}"
    * "{{display}}"

**Backwards compatible** veranderingen zijn:
    * Een [=tabel=] is toegevoegd aan een dataset.
    * Een [=veld=] is toegevoegd aan een tabel.

**Niet backwards compatible** zijn alle andere aanpassingen:
    * Een [=tabel=] is verwijderd of hernoemd in een dataset.
    * Een [=veld=] is verwijderd of hernoemd.
    * Een optioneel veld wordt verplicht gemaakt.
    * Inputmogelijkheden van een veld zijn verruimd (zoals wanneer een waarde aan {{enum}} is toegevoegd,
        of een {{maximum}} of {{minimum}} is verruimd).

Note: Deze semantic versioning standaard is geinspireerd door [[SCHEMVER inline]] wat weer is gebaseerd op [[SEMVER inline]].

<!--
█▌   █▌ █████▌ ████▌   ███▌  ████ █████▌
█▌   █▌ █▌     █▌  █▌ █▌  █▌  ▐▌  █▌
█▌   █▌ █▌     █▌  █▌ █▌      ▐▌  █▌
▐▌   █  ████   ████▌   ███▌   ▐▌  ████
 █  ▐▌  █▌     █▌▐█       █▌  ▐▌  █▌
 ▐▌ █   █▌     █▌ ▐█  █▌  █▌  ▐▌  █▌
  ▐█    █████▌ █▌  █▌  ███▌  ████ █████▌
-->

Versie {#dataset-version}
======================================================

Een [=versie=] definitie beschrijft een versie van de dataset, met daarin de status, versienummer en tabellen die
bij deze versie horen.

Verplichte attributen {#version-mandatory-fields}
-------------------------------------------------------
Een <dfn dfn export>versie</dfn> binnen Amsterdam Schema is een JSON object met in ieder geval de volgende attributen:
<table dfn-type="attribute" dfn-for=versie export class="dfn-table">
    <tr><td><dfn>status</dfn>   <td> string
        <td> Publicatiestatus van de versie van de dataset
            <details>
                <summary>Toegestane waarden</summary>
                    * "beschikbaar"
                    * "niet_beschikbaar"
            </details>
    <tr><td><dfn>version</dfn>  <td> {{version-string}}     <td> Het versie nummer van deze versie. Zie [[#dataset-versioning]]
    <tr><td><dfn>lifecycleStatus</dfn>   <td> string
        <td> Lifecycle van de versie van de dataset. Zie [[#version-lifecycle-status]]
            <details>
                <summary>Toegestane waarden</summary>
                    * "experimental"
                    * "stable"
            </details>
    <tr><td><dfn>tables</dfn>             <td> object
        <td> Tabellen in deze versie van de dataset. Moet minimaal 1 element bevatten.
            <details>
                <summary>Valide elementen</summary>
                * een [=tabel=] json object
                * een referentie naar een JSON bestand van een tabel.
                    Zie [[#table-refs]] voor details.
            </details>
</table>

[HIDELINESEXAMPLE]
    Voorbeeld van een dataset met twee versies en twee tabelreferenties.

    Een `locaties` tabel in `./locaties/v1.json`.<br/>
    En een `personen` tabel in `./personen/v2.json`, waarvan ook de oudere versie `v1` beschikbaar is.
    <pre class="include-code">
            path: examples/datasets/bekendeAmsterdammers/dataset.json
            highlight: json
            line-highlight: 11-40
        </pre>
[END]

Lifecycle {#version-lifecycle-status}
--------------------------
Een versie van een dataset dient een lifecycleStatus te hebben. Momenteel zijn de opties hiervoor 'experimental' of
'stable'. Deze lifecycleStatus zegt iets over de stabiliteit van een versie van een dataset. Wanneer een versie 'stable'
is, zullen er geen breaking changes meer plaatsvinden. Een versie met de status 'experimental' is nog in ontwikkeling en
kan tijdens deze periode nog veranderen.

Note: In de toekomst zal dit veld o.a. ook gebruikt worden voor het aangeven of een versie uitgefaseerd ('deprecated') is.

<!--
████████    ███    ████████  ████████ ██
   ██      ██ ██   ██     ██ ██       ██
   ██     ██   ██  ██     ██ ██       ██
   ██    ██     ██ ████████  ██████   ██
   ██    █████████ ██     ██ ██       ██
   ██    ██     ██ ██     ██ ██       ██
   ██    ██     ██ ████████  ████████ ████████
-->
Tabel {#tables}
======================================================

Een [=tabel=] definitie bevat het schema waaraan de er toe behorende datarijen moeten voldoen.
Binnen het schema worden velden gedefinieerd die datarijen moeten of mogen bezitten.
Daarnaast kan aan een tabel meta informatie en autorisatie instellingen worden meegegeven.

Verplichte attributen {#tabel-mandatory-fields}
---------------------------------------------------------
Een <dfn dfn export>tabel</dfn> binnen Amsterdam Schema is een JSON object met in ieder geval de volgende attributen.
<table dfn-type="attribute" dfn-for=tabel export class="dfn-table">
    <tr><td><dfn>id</dfn>       <td> {{id-type|identifier}} <td> Naam van de tabel. Unieke (binnen de parent dataset) identifier voor deze tabel. Moet voldoen aan [[#naamgeving]].
    <tr><td><dfn>type</dfn>     <td> {{schema-type}}        <td> Type van dit bestand, in dit geval `"table"`.
    <tr><td><dfn>version</dfn>  <td> {{version-string}}     <td> Het versie nummer van deze tabel. Zie [[#table-versioning]]
    <tr><td><dfn>lifecycleStatus</dfn>   <td> string
        <td> Lifecycle van de tabel. Zie [[#table-lifecycle-status]]
            <details>
                <summary>Toegestane waarden</summary>
                    * "experimental"
                    * "stable"
            </details>
    <tr><td><dfn>schema</dfn>   <td> object
        <td> Het schema van objecten in de tabel. zie [[#tabel-schema]]
            <details>
                <summary>Valide elementen</summary>
                * een [=schema-object=]
                * een [[JSON-SCHEMA#ref|referentie]] naar een JSON bestand van een [=schema-object=].
            </details>
</table>

Advisement: Let op: Zie [[#naamgeving]] voor de eisen waaraan {{tabel/id}} moet voldoen.

[HIDELINESEXAMPLE]
    Voorbeeld van een minimale tabel definitie. De {{tabel/title}} en {{tabel/description}} velden zijn niet verplicht,
    maar het is best practice ze toe te voegen.
    <pre class="include-code">
        path: examples/datasets/minimaal/personen/v1.json
        highlight: json
        line-highlight: 0-8,26-28
    </pre>
[END]


Optionele attributen {#tabel-optional-fields}
---------------------------------------------------------
Een  [=tabel=] mag daarnaast de volgende attributen bezitten:
<table dfn-type="attribute" dfn-for=tabel export class="dfn-table">
    <tr><td><dfn>title</dfn>        <td> string <td> zie [[#omschrijving]] Default: Gelijk aan {{tabel/id}}.
    <tr><td><dfn>description</dfn>  <td> string <td> zie [[#omschrijving]]
    <tr><td><dfn>shortname</dfn>    <td> string <td> Verkorte unieke naam van de tabel. zie [[#naamgeving]]
    <tr><td><dfn>derivedFrom</dfn>  <td> array<td> De datasets waar deze view op gebaseerd is. e.g. `<dataset>:<tabel>`. Dit attribuut is enkel noodzakelijk wanneer de dataset een view is.
    <tr><td><dfn>auth</dfn>         <td> string | array | [[#scope-refs|scope-ref]] <td> geautoriseerde [=scope|scope(s)=]. Default: gelijk aan waarde in dataset/{{dataset/auth}}, zie [[#autorisatie]].
    <tr><td><dfn>rowLevelAuth</dfn> <td> object <td> De row level authorisaties van toepassing op deze tabel, zie [[#row_level_auth]]
    <tr><td><dfn>reasonsNonPublic</dfn>  <td> array({{nonPubReason}})
        <td> een of meer gronden voor het niet openbaar maken van data obv uitzonderingen in Hoofdstuk 5 van de [[Woo]].
            Verplicht wanneer de dataset openbaar is maar het {{tabel/auth}} attribuut van de tabel niet gelijk is aan "OPENBAAR". zie [[#autorisatie]]
    <tr><td><dfn>provenance</dfn>   <td> string <td> zie [[#provenance]]
    <tr><td><dfn>dateCreated</dfn>  <td> {{date-time}} <td> Datum van publicatie.
    <tr><td><dfn>dateModified</dfn> <td> {{date-time}} <td> Meest recente datum waarop de tabel is aangepast.
    <tr><td><dfn>license</dfn>      <td> string <td> Licentie
    <tr><td><dfn>temporal</dfn>     <td> [=temporal-object=] <td> Definieert tijdsafhankelijke geldigheid van objecten. zie [[#temporaliteit]]
    <tr><td><dfn>crs</dfn>
        <td> enum(string)
        <td> Coordinate reference System
            <details open>
                <summary>Opties</summary>
                    * "EPSG:28992"
                    * "EPSG:4326"
                    * "EPSG:7415"
            </details>
            Dit veld is **verplicht** voor tabellen waarin één of meer [[#geometry]] velden zitten en waarvoor niet op dataset-of veldniveau al een crs gedefinieerd is.
            Zie [[SDW-BP#CRS-background]] voor meer informatie.
    <tr><td><dfn>dataclass</dfn>
        <td> enum(string)
        <td> Soort data in de tabel
            <details open>
                <summary>Opties</summary>
                    * "structured"
                    * "blob"
                    * "event"
            </details>
            Default: `"structured"`
    <tr><td><dfn>zoom</dfn><td> object <td> De zoom niveaus waarbinnen de velden getoond moeten worden. zie [[#zoom]]
</table>

[BP]
    Voeg altijd op zijn minst een {{tabel/title}} en {{tabel/description}} toe.
[BPE]

Schema {#tabel-schema}
------------------------------------------

Het <dfn lt=schema|schema-object export>schema</dfn> object beschrijft de eigenschappen van rijen in de tabel.

Een [=schema=] object moet in ieder geval de volgende attributen bezitten:
<table dfn-type="attribute" dfn-for=schema export class="dfn-table">
    <tr><td><dfn>$schema</dfn>      <td> string <td> [CONST] `"http://json-schema.org/draft-07/schema#"`
    <tr><td><dfn>type</dfn>         <td> string <td> [CONST] `"object"`
    <tr><td><dfn>required</dfn>     <td> array (string) <td> Namen van [=veld|velden=] die niet `null` mogen bevatten. Bevat minstens `"schema"`.
    <tr><td><dfn>display</dfn>      <td> string
        <td>  De naam van het [=veld=] dat titel van objecten bevat.
            Voor afnemers die een samenvattende titel van een object willen tonen. Default: gelijk aan {{schema/identifier}}.
            Het veld dat hier genoemd wordt mag geen {{veld/auth}} attribuut bevatten.
    <tr><td><dfn>properties</dfn>   <td> object
        <td> Collectie van [=veld|velden=] die rijen in de tabel mogen bezitten. Bevat daarnaast een 'schema.$ref' attribuut.
            Veldnamen moeten beginnen met een kleine letter gevolgd door een alfanumerieke reeks en moeten voldoen aan [[#naamgeving]].
    <tr><td><dfn>properties.schema</dfn>   <td> [[JSON-SCHEMA#ref|§ref]]  <td> [CONST] `{"$ref":"https://schemas.data.amsterdam.nl/schema@v3.1.0#/definitions/schema"}`
</table>

Daarnaast mag een [=schema=] object de volgende attributen bezitten:
<table dfn-type="attribute" dfn-for=schema export class="dfn-table">
    <tr><td><dfn>$id</dfn>                      <td> string <td>
    <tr><td><dfn>additionalProperties</dfn>     <td> bool <td> [CONST] `false` Geeft aan dat objecten extra velden mogen hebben.
    <tr><td><dfn>mainGeometry</dfn>             <td> string <td> De naam van het primaire geometrie veld. Default: `"geometry"` zie [[#geometry]]
    <tr><td><dfn>identifier</dfn>               <td> string | array (string)
        <td>Naam van het [=veld=] dat de unieke identifier van een rij is, of een array van veldnamen die samen een unieke key vormen.
            Het veld of de velden waar hier naar verwezen wordt moeten van het type [[#data-types-string|string]] of het type [[#data-types-int|integer]] zijn.
            en mogen geen {{veld/auth}} attribuut bevatten.
</table>

Issue: Het identifier veld moet string zijn. De array optie wordt binnenkort verwijderd.

[HIDELINESEXAMPLE]
    Voorbeeld van een schema.

    Het {{display}} veld zorgt ervoor dat niet de "id" de maar de "naam" van een persoon als samenvattende titel wordt gebruikt.
    <pre class=include-code>
        path: examples/datasets/minimaal/personen/v1.json
        highlight: json
        line-highlight: 8-26
    </pre>
[END]


Temporaliteit {#temporaliteit}
-----------------------------------------------

Als een tabel objecten bevat die slechts beperkte tijd geldig zijn of waarvan over de tijd verschillende versies geldig zijn,
wordt dit in de tabel definitie met het <dfn lt=temporal-object|temporal export>temporal</dfn> object aangegeven.

Een [=temporal=] object heeft in ieder geval de volgende attributen.
<table dfn-type="attribute" dfn-for=temporal export class="dfn-table">
    <tr><td><dfn>identifier</dfn>                <td> string
        <td> Naam van het veld dat de versie van een object identificeert.
            De combinatie van dit veld en het veld waarnaar wordt verwezen in het {{schema/identifier}} attribuut van schema moet uniek zijn voor elke regel in de tabel.
    <tr><td><dfn>dimensions.geldigOp</dfn> <td> array (string)<td> De namen van de velden die de geldigheid van een object begrenzen. Heeft 2 elementen.
</table>

Note: Momenteel wordt alleen de dimensie "geldigOp" ondersteund.
      In de toekomst kunnen hier andere dimensies zoals "inWerkingOp" en "beschikbaarOp" aan toegevoegd worden.

De array in {{temporal/dimensions.geldigOp|temporal.dimensions.geldigOp}} bevat de namen van twee velden met begin en eind geldigheid van een object.
Een object in de tabel is geldig binnen het gesloten interval ["beginGeldigheid", "eindGeldigheid"].

Als een tabel niet temporeel is kan het [=temporal|temporal object=] worden weggelaten.

<div class=example>
Voorbeeld van een temporal object.
    ```json
        "temporal": {
            "identifier": "volgnummer",
            "dimensions": {
                "geldigOp": ["beginGeldigheid", "eindGeldigheid"]
            }
        }
    ```
</div>


Versionering {#table-versioning}
--------------------------
Verschillende versies van een tabel worden van elkaar onderscheiden door middel van versienummers.

Een geversioneerde tabel moet in een eigen bestand staan.
De bestandsnaam van de tabel **zou** gelijk moeten zijn aan het major versienummer van de tabel voorafgegaan
door 'v' met een '.json' extensie. Zie [[#table-refs]] voor hoe in de dataset naar een tabel bestand moet worden
verwezen.

Zie [[#dataset-versioning]] voor uitleg over semantic versioning.

Zie [[#table-refs]] voor het toevoegen van verschillende versies van een tabel.

[HIDELINESEXAMPLE]
    Voorbeeld aan versie "1.2.1" van de personen tabel wordt een nieuw veld toegevoegd en aan een bestaand {{enum}}
    veld wordt een optie toegevoegd.

    Dit zijn backwards compatible veranderingen dus het minor versienummer wordt opgehoogd en de nieuwe versie
    wordt "1.3.0". Voor deze wijzigingen hoeven dus geen nieuwe bestanden aangemaakt te worden, omdat de
    major version niet verhoogd.

    <div style="text-align:center;">
        `personen/v2.json`
        <div class="compare-code">
            [COMPAREA]
                <pre class="include-code">
                    path: examples/datasets/bekendeAmsterdammers/personen/v1.2.1.json
                    highlight: json
                    line-highlight: 5,28,31-34
                </pre>
            [END]
            [COMPAREB]
                <pre class="include-code">
                    path: examples/datasets/bekendeAmsterdammers/personen/v1.3.0.json
                    highlight: json
                    line-highlight: 5,28, 31-35,37-44
                </pre>
            [END]
        </div>
    </div>
[END]

[HIDELINESEXAMPLE]
    Nu wordt in de tabel uit het vorige voorbeeld een veld hernoemd, wordt uit een {{enum}} veld een optie verwijderd
    en wordt een optioneel veld verplicht gemaakt.

    Deze veranderingen zijn niet backwards compatible dus het major versie nummer wordt opgehoogd en de
    nieuwe versie wordt "2.0.0".

    De nieuwe tabel wordt in een nieuw bestand `personen/v2.json` geplaatst.
    <div class="compare-code">
        [COMPAREA]
            `personen/v1.json`
            <pre class="include-code">
                path: examples/datasets/bekendeAmsterdammers/personen/v1.3.0.json
                highlight: json
                line-highlight: 5,10-13,19-23,31-35
            </pre>
        [END]
        [COMPAREB]
            `personen/v2.json`
            <pre class="include-code">
                path: examples/datasets/bekendeAmsterdammers/personen/v2.0.0.json
                highlight: json
                line-highlight: 5,10-14,20-25,33-40
            </pre>
        [END]
    </div>
[END]

[HIDELINESEXAMPLE]
    Voorbeeld in versie 2.0.0" wordt een aantal metadata velden aangepast.

    Deze veranderingen passen de data structuur niet aan dus het patch nummer wordt opgehoogd en de nieuwe versie wordt "2.0.1".

    Er hoeft in dit geval dus geen nieuw bestand gemaakt te worden.

    <div style="text-align:center;">
        `personen/v2.json`
        <div class="compare-code">

            [COMPAREA]
                <pre class="include-code">
                    path: examples/datasets/bekendeAmsterdammers/personen/v2.0.0.json
                    highlight: json
                    line-highlight: 5-6,15,31,44
                </pre>
            [END]
            [COMPAREB]
                <pre class="include-code">
                    path: examples/datasets/bekendeAmsterdammers/personen/v2.0.1.json
                    highlight: json
                    line-highlight: 5-6,15,31,44
                </pre>
            [END]
        </div>
    </div>
[END]

[HIDELINESEXAMPLE]
    Om de nieuwe versie van de tabel aan de [=dataset=] toe te voegen, moet er een nieuwe versie aan het dataset bestand
    toegevoegd worden, waarin de [=tabelreferentie=] in de dataset ook aangepast worden.
    De defaultVersion van de dataset is nu "v2" en de status van de juiste versie wordt aangepast naar beschikbaar.

    In dit geval staat de versie "1.3.0" ook in "v1" zodat de oudere versie van de data ook beschikbaar blijft.

    <div style="text-align:center;">
        `personen/dataset.json`
        <pre class="include-code">
            path: examples/datasets/bekendeAmsterdammers/dataset.json
            highlight: json
            line-highlight: 1,12-19,26-33
        </pre>
    </div>
[END]

Lifecycle {#table-lifecycle-status}
--------------------------
Een tabel van een dataset dient een lifecycleStatus te hebben. Momenteel zijn de opties hiervoor 'experimental' of
'stable'. Deze lifecycleStatus zegt iets over de stabiliteit van een tabel. Wanneer een versie 'stable'
is, zullen er geen breaking changes meer plaatsvinden. Bij de validatie van het schema wordt er gecontroleerd of een
wijziging in een 'stable' tabel geen breaking changes bevat. Een tabel met de status 'experimental' is nog in
ontwikkeling en kan tijdens deze periode nog veranderen.

Zoom {#zoom}
--------------
Een tabel met een of meer geovelden kan via vectortiles (MVT) worden opgevraagd. Aangezien sommige tabellen
flinke hoeveelheden data bevatten, is het vaak raadzaam om niet alle data op te vragen op elk zoomniveau. De
identifiers worden op elk niveau getoond, maar andere velden alleen als ze binnen de zoom.min en zoom.max (beide
inclusief) vallen.

In het onderstaande voorbeeld zullen alle velden meegegeven worden als de zoom >= 12 en <= 17.

<div class=example>
Voorbeeld van een zoom object op een tabel.
    ```json
        "zoom": {
            "min": 12,
            "max": 17
        }
    ```
</div>

De waarde van "min" dient kleiner te zijn dan die van "max", en valide waarden zijn van 0 tot 30.
Een indicatie van de reikwijdte van een laag bij verschillende zoomniveaus:

7: geheel Nederland
12: geheel Amsterdam
14: de binnenring
17/18: een woonblok
20/21: een pand

Je kunt op [deze](https://docs.maptiler.com/google-maps-coordinates-tile-bounds-projection/) site zelf bekijken
welke zoomniveaus voor jouw tabel passend zijn.

Het zoom object is niet verplicht. Indien de zoom niet wordt meegegeven, zullen de velden meegegeven worden vanaf
niveau 15.

Row Level Authorisatie {#row_level_auth}
------------------------------------------
Indien velden afgeschermd of getoond dienen te worden op basis van de waarde van een
ander veld in de regel (bijvoorbeeld als iemand geheimhouding heeft aangevraagd van zijn
of haar adres), dan kan dit met rowLevelAuth worden aangegeven.

Een rowLevelAuth object heeft de volgende attributen:
<table dfn-type="attribute" dfn-for=rowLevelAuth export class="dfn-table">
    <tr><td><dfn>source</dfn>  <td> string <td> het bronveld op basis waarvan andere velden dienen te worden afgeschermd.
    <tr><td><dfn>targets</dfn> <td> array (string) <td> de velden die afgeschermd dienen te worden.
    <tr><td><dfn>authMap</dfn> <td> object <td> een mapping van waarden van het source veld ("true" en "false")
    naar authorisatie scopes.
</table>

De namen van velden in `source` en `targets` kunnen verwijzen naar geneste velden (in objecten in het schema) middels een `.`.

<div class=example>
Voorbeeld van een rowLevelAuth object op een tabel.
    ```json
        "rowLevelAuth": {
            "source": "adresAfgeschermd",
            "targets": ["adres.straat", "adres.huisnummer", "adres.postcode", "telefoonnummer"],
            "authMap": {
                "true": ["BRP/ADMIN"],
                "false": ["BRP/R"]
            }
        }
    ```
</div>

In dit voorbeeld kijken we naar de waarde van `adresAfgeschermd`. Als deze waarde `false` is, dan zijn
straat, huisnummer en postcode in het adres object (geneste items hebben een `.`), evenals het
telefoonnummer zichtbaar voor gebruikers met BRP/R authorisatie. Als `adresAfgeschermd` echter `true`
is, dan zal het alleen toegankelijk zijn voor iemand met BRP/ADMIN authorisatie. Voor dergelijke regels
kan via deze weg dus een hoger authorisatieniveau worden afgedwongen.

Bij het aanmaken of aanpassen van het schema wordt het volgende gevalideerd:
- `source` zit niet in `targets`
- `source` bestaat en heeft als type "boolean"
- alle `targets` bestaan

<!--
██     ██ ████████ ██       ████████
██     ██ ██       ██       ██     ██
██     ██ ██       ██       ██     ██
██     ██ ██████   ██       ██     ██
 ██   ██  ██       ██       ██     ██
  ██ ██   ██       ██       ██     ██
   ███    ████████ ████████ ████████
-->
Veld {#fields}
======================================================
Een veld beschrijft een eigenschap die een rij in de tabel mag of moet (zie {{required}}) bezitten.
Een [=veld=] is een concrete JSON Schema-typedefinitie waaraan ook meta-informatie kan worden meegegeven.

Zie [[#data-types]] voor een overzicht van modelleerbare typen en hoe deze binnen Amsterdam Schema uitgedrukt kunnen worden.

Note: [=veld=] gebruikt een subset van [[!json-schema-validation]]. Een aantal JSON Schema features waaronder union types wordt niet ondersteund.

Advisement: Let op: Zie [[#naamgeving]] voor de eisen waaraan de namen van velden moeten voldoen.

Verplichte attributen {#veld-mandatory-fields}
--------------------------------------------------------------------
Een <dfn export>veld</dfn> is een JSON object met in ieder geval één en niet meer dan één van de volgende twee attributen.
<table dfn-type="attribute" dfn-for=veld export class="dfn-table">
    <tr><td><dfn>type</dfn>             <td> string
        <td> [[#data-types| Data type]] van het veld.  Volgens [[json-schema-validation#rfc.section.6.1.1]]. Zie [[#data-types]] voor details.
            <details>
                <summary>Toegestane waarden</summary>
                    * "[[#data-types-int|integer]]"
                    * "[[#data-types-number|number]]"
                    * "[[#data-types-bool|boolean]]"
                    * "[[#data-types-string|string]]"
                    * "null"
                    * "[[#data-types-object|object]]"
                    * "[[#data-types-array|array]]"

            </details>
     <tr><td><dfn lt=ref>$ref</dfn>  <td> enum({{uri-type|uri}})
         <td> URI van een GeoJSON geometry schema definitie. zie [[#geometry]]
            <details>
                <summary>Opties</summary>
                    * "https://geojson.org/schema/Geometry.json"
                    * "https://geojson.org/schema/MultiPolygon.json"
                    * "https://geojson.org/schema/Polygon.json"
                    * "https://geojson.org/schema/Point.json"
                    * "https://geojson.org/schema/MultiLineString.json"
                    * "https://geojson.org/schema/LineString.json"
                    * "https://geojson.org/schema/MultiPoint.json"
            </details>
         </td>
</table>

Note: Let op, een veld moet dus een {{veld/type}} **of** een {{veld/ref|$ref}} attribuut hebben, beide is **niet** toegestaan.

Toegestane attributen {#permitted-attributes}
--------------------------------------------------------------------
Een [=veld=] definitie mag naast het [[#veld-mandatory-fields|verplichte attribuut]] optioneel de volgende meta-data attributen bevatten:
<table dfn-type="attribute" dfn-for=veld export class="dfn-table">
    <tr><td><dfn>title</dfn>            <td> string <td> zie [[#omschrijving]] Default: Gelijk aan de naam van het veld.
    <tr><td><dfn>description</dfn>      <td> string <td> zie [[#omschrijving]]
    <tr><td><dfn>auth</dfn>             <td> string | array | scope-$ref
        <td> geautoriseerde [=scope|scope(s)=]. Default: gelijk aan waarde in tabel/{{tabel/auth}}, zie [[#autorisatie]].
            Niet toegestaan in velden waarnaar wordt verwezen in {{schema/identifier}} of {{schema/display}}.
    <tr><td><dfn>filterAuth</dfn>        <td> string | array
        <td> geautoriseerde [=scope|scope(s)=] die dit veld in zoekvragen mogen gebruiken.
             De gebruiker moet daarnaast leestoegang hebben tot het veld via {{veld/auth}} of [[#profielen]].
    <tr><td><dfn>reasonsNonPublic</dfn>  <td> array({{nonPubReason}})
        <td> een of meer gronden voor het niet openbaar maken van data obv uitzonderingen in Hoofdstuk 5 van de [[Woo]].
            Verplicht wanneer de tabel openbaar is maar het {{veld/auth}} attribuut van het veld niet gelijk is aan "OPENBAAR". zie [[#autorisatie]]
    <tr><td><dfn>provenance</dfn>       <td> string <td> zie [[#provenance]]
    <tr><td><dfn>shortname</dfn>        <td> string <td> zie [[#naamgeving]]
    <tr><td><dfn>unit</dfn>             <td> string | object <td> De eenheid van de waarden in dit veld. zie [[#units]]
    <tr><td><dfn>relation</dfn>         <td> string <td> Beschrijft relaties tussen velden. zie [[#relatering]]
    <tr><td><dfn>uri</dfn>              <td> {{uri-reference}} <td> Een verwijzing de definitie van de waarden in dit veld.
    <tr><td><dfn>crs</dfn>
        <td> enum(string)
        <td> Coordinate reference System
            <details open>
                <summary>Opties</summary>
                    * "EPSG:28992"
                    * "EPSG:4326"
                    * "EPSG:7415"
            </details>
            Dit veld is **verplicht** voor [[#geometry]] velden waarvoor niet op dataset-of tabelniveau al een crs gedefinieerd is.
            Zie [[SDW-BP#CRS-background]] voor meer informatie.
</table>

[BP]
    Voeg altijd op zijn minst een '{{veld/title}}' en '{{veld/description}}' toe.
[BPE]

Naast bovenstaande attributen mag een [=veld=] uitsluitend de volgende subset van attributen uit [[!json-schema-validation| JSON Schema]] bevatten:
<table dfn-type="attribute" dfn-for=veld export class="dfn-table">
    <tr><td><dfn>$comment</dfn>         <td> string <td> Developer commentaar bij het veld.
    <tr><td><dfn>items</dfn>            <td> [=veld=]
        <td> JSON Schema van de elementen in de array. (verplicht voor array type)
            In tegenstelling tot JSON Schema wordt een `array` hier niet ondersteund. Zie [#data-types-array].
    <tr><td><dfn>maximum</dfn>          <td> number <td> Inclusieve maximum waarde (voor integer en number type)
    <tr><td><dfn>minimum</dfn>          <td> number <td> Inclusieve minimum waarde (voor integer en number type)
    <tr><td><dfn>exclusiveMaximum</dfn> <td> integer <td> Exclusieve maximum waarde (voor integer en number type)
    <tr><td><dfn>multipleOf</dfn>       <td> number <td> Waarde moet meervoud zijn van (voor integer en number type)
    <tr><td><dfn>minLength</dfn>        <td> integer <td> Mimimum lengte (voor string type)
    <tr><td><dfn>maxLength</dfn>        <td> integer <td> Maximum lengte (voor string type)
    <tr><td><dfn>contentEncoding</dfn>  <td> string <td> Encoding (voor string type)
    <tr><td><dfn>properties</dfn>       <td> object <td> Attributen van objecten (voor object type)
    <tr><td><dfn>enum</dfn>             <td> array <td> Lijst van maximaal 1024 toegestane waarden.
    <tr><td><dfn>format</dfn>           <td> string/object
        <td> String formats (voor string type) Conform [[json-schema-validation#rfc.section.7.3]].
            <details>
                <summary>Opties</summary>
                    * "date-time"
                    * "time"
                    * "date"
                    * "duration"
                    * "email"
                    * "idn-email"
                    * "hostname"
                    * "idn-hostname"
                    * "ipv4"
                    * "ipv6"
                    * "uri"
                    * "uri-reference"
                    * "iri"
                    * "iri-reference"
            </details>

            Object format (voor object type): "json"

</table>

<div class=example>
    Voorbeeld van een veld.
    <pre class=include-code>
        path: examples/datasets/bekendeAmsterdammers/personen/v1.2.1.json
        highlight: json
        show: 24-29
    </pre>
</div>

<div class=example>
    Voorbeeld van een geometrie veld.
    <pre highlight="json">
        "locatie": {
            "title": "Locatie",
            "description": "Coordinaten van het middelpunt van het plein",
            "$ref" : "https://geojson.org/schema/Point.json"
        }
    </pre>
</div>

Data types {#data-types}
-------------------------------

Velden worden allemaal gemodelleerd als concrete JSON Schema type definieringen,
deze moeten in doel-systemen naar de juiste veld/kolom-types getransformeerd worden.
(Zie ook [Type-specific keywords](https://json-schema.org/understanding-json-schema/reference/type.html) in de JSON Schema specificatie).

Deze sectie bevat een overzicht van de door Amsterdam Schema ondersteunde JSON Schema typen, voorbeelden van gebruik en
welke (SQL) data typen gebruikt zouden moeten worden om de JSON Schema typen te interpreteren.

<table class=lst-table>
    <tr><td> [[#data-types-int]]       <td> [[#data-types-time]]
    <tr><td> [[#data-types-number]]    <td> [[#geometry]]
    <tr><td> [[#data-types-bool]]      <td> [[#data-types-object]]
    <tr><td> [[#data-types-string]]    <td> [[#data-types-array]]
</table>

Note: UNION types worden niet ondersteund: een kolom kan niet meerdere typen waardes bevatten, behalve `null`.
    De anyOf operater is dus **niet** toegestaan<br /> <del>`{"anyOf": [{ "type": "integer" }, { "type": "string"}]}`</del>

Note: Elk veld is nullable tenzij het als `required` property is opgegeven, zie {{required}}.

### integer ### {#data-types-int}
    Een integer bevat de (decimale representatie van) een 64-bits signed integer.
    Een integer in Amsterdam Schema heeft dus een range van `[-(2^63), (2^63)-1]`, maar gebruik van getallen buiten het bereik `[-(2^53)+1, (2^53)-1]`
    wordt in lijn met [[RFC7159#section-6]] afgeraden omdat dit door veelgebruikte doelsystemen ([[IEEE754]])
    niet wordt ondersteund. Als een {{maximum}} en/of {{minimum}} buiten de laatst genoemde range is ingesteld wordt een waarschuwing gegeven.

    <div class=example>
        Dit veld bevat een 64-bits signed integer, zoals een "BIGINT" in SQL.
        <pre highlight="json">
            "aantalDuivenOpDeDam": {
                "title": "aantal duiven op de Dam",
                "description": "Het gemeten aantal duiven op de de Dam",
                "type": "integer"
            }
        </pre>
    </div>

    <div class=example>
        Dit veld resulteert in een waarschuwing.
        <pre highlight="json">
            "zandkorrelsOpBlijburg": {
                "title": "zandkorrels op Blijburg",
                "description": "Het aantal aantal zandkorrels op het strand van Blijburg.",
                "type": "integer",
                "maximum": 1E19
            }
        </pre>
    </div>

    Daar waar een kleiner bereik is gegeven door middel van een of meer van de attributen {{maximum}}, {{minimum}} of {{exclusiveMaximum}}
    kan een native datatype met een geschikt bereik worden toegepast.
    Zo kan een `integer` met een {{exclusiveMaximum}} `< 2^(N-1)` en {{minimum}} `>= 2^(N-1)` altijd worden geinterpreteerd als een N-bits signed integer.
    <div class=example>
        Dit veld kan veilig als 32 bit signed integer (zoals een SQL `INTEGER`) worden geinterpreteerd. (`2147483648 = 2^(32-1)`)
        <pre highlight="json">
            "hoogteTenOpzichteVanNormaalAmsterdamsPijl": {
                "title": "Hoogte ten opzichte van NAP",
                "shortname": "hoogteNAP"
                "description": "Hoogte van de locatie ten opzichte van NAP in cm.",
                "type": "integer",
                "exclusiveMaximum": 2147483648,
                "minimum": -2147483648,
                "unit": "cm"
            }
        </pre>
    </div>

    Een integer met een {{minimum}} `>= 0` en een {{exclusiveMaximum}} `< 2^N` kan altijd worden geinterpreteerd als een N-bits unsigned integer.
    <div class=example>
        Dit veld kan veilig als 8 bit unsigned integer zoals een SQL `TINYINT` worden geinterpreteerd.
        <pre highlight="json">
            "weeknummer": {
                "title": "weeknummer",
                "description": "weeknummer",
                "type": "integer",
                "exclusiveMaximum": 256,
                "minimum": 0,
            }
        </pre>
    </div>

    Het wordt aangeraden om de toegestane waarden in een veld altijd te beperken tot realistische waarden om fouten te voorkomen.
    <pre class=example highlight="json">
        "decennium": {
            "title": "decennium",
            "description": "Een decennium in het bestaan van de stad.",
            "type": "integer",
            "exclusiveMaximum": 2121,
            "minimum": 1300,
            "multipleOf": 10
        }
    </pre>


### number ### {#data-types-number}
    Number wordt gebruikt voor velden met reële getallen. Als geen {{multipleOf}} attribuut is meegegeven moet een `number` veld worden geinterpreteerd
    als een 64bits floating-point getal (`double`) zoals een SQL `DOUBLE`.
    Dit veld moet worden geinterpreteerd als een Double zoals een SQL `DOUBLE`.
    <pre class=example highlight="json">
        "gevelHoek": {
            "title": "gevel hoek",
            "description": "Hoek van de gevel met de verticaal in graden",
            "type": "number"
        }
    </pre>

    Wanneer aan een `number` veld een {{multipleOf}} attribuut is meegegeven moet dit veld worden geinterpreteerd
    als fixed-point type met `schaal=log(multipleOf)/log(0.1)` (zodat {{multipleOf}}`=0.1^schaal`).
    <div class=example>
        Dit veld moet worden geinterpreteerd als een fixed-point type met schaal=2 zoals een SQL `DECIMAL(10,2)`.
        <pre highlight="json">
            "gevelHoek": {
                "title": "gevel hoek",
                "description": "Hoek van de gevel met de verticaal in graden",
                "type": "number",
                "multipleOf": 0.01
            }
        </pre>
    </div>

    Als een maximum attribuut is meegegeven kan een native type met een geschikte precisie worden gebruikt.
            `precisie = log(maximum + 1)/log(10) + schaal` (zodat {{maximum}}`=10^(precisie-schaal) -1`).
    <div class=example>
        Dit veld moet worden geinterpreteerd als een fixed-point type met schaal=2 en precisie>=4 zoals een SQL `DECIMAL(4,2)`.
        <pre highlight="json">
            "gevelHoek": {
                "title": "gevel hoek",
                "description": "Hoek van de gevel met de verticaal in graden",
                "type": "number",
                "multipleOf": 0.01
                "maximum": 90
                "minimum": -90
            }
        </pre>
    </div>

    [BP]
        Beperk numerieke velden altijd tot realistische waarden met {{maximum}}, {{minimum}} of {{exclusiveMaximum}} om fouten te voorkomen,
        en doelsystemen de juiste datatypen te laten gebruiken.
    [BPE]

### boolean ### {#data-types-bool}
    Een [=veld=] van het type `"boolean"` wordt gebruikt voor boolean, (`true`, `false`) waarden.
    <pre class=example highlight="json">
        "isGepubliceerd": {
            "title": "Is gepubliceerd",
            "description": "Dit artikel is gepubliceerd.",
            "type": "boolean",
        }
    </pre>

### string ### {#data-types-string}
    String velden worden gebruikt voor tekst, enums, tijd, datum en binary data.
    Waarden in een `string` veld moeten standaard worden geinterpreteerd als van een string type zoals een SQL `TEXT`.
    <pre class=example highlight="json">
        "beschrijving": {
            "title": "Beschrijving",
            "description": "Beschrijving van het pand.",
            "type": "string",
        }
    </pre>

    Waar een {{maxLength}} attribuut is meegegeven aan een `string` veld kan een geschikt limited width string type zoals een SQL `VARCHAR` worden gebruikt.
    <pre class=example highlight="json">
        "bekendeUitspraak": {
            "title": "Bekende uitspraak",
            "description": "Bekende uitspraak van de persoon.",
            "type": "string",
            "maxLength": 50
        }
    </pre>

    Als een `string` veld een {{minLength}} en een {{maxLength}} attribuut van gelijke waarde heeft kan het veld worden geinterpreteerd als een fixed width string
    zoals een SQL `CHAR`.
    <pre class=example highlight="json">
        "taalcode": {
            "title": "taalcode",
            "description": "Taalcode volgens de ISO639-2 standaard.",
            "type": "string",
            "maxLength": 3
            "minLength": 3
        }
    </pre>

    Wanneer in een `text` veld een beperkte set waarden is toegestaan door middel van het {{enum}} attribuut,
    zou het veld moeten worden geinterpreteerd als een enumerator type zoals een SQL `ENUM`.
    <div class=example>
        Dit veld zou moeten worden geinterpreteerd als een enumerator zoals een SQL `ENUM`.
        <pre highlight="json">
            "beroep": {
                "title": "beroep",
                "description": "Beroep van de persoon.",
                "type": "string",
                "enum": ["voetballer", "filosoof", "beide"]
            }
        </pre>
    </div>

    Een text veld met {{contentEncoding}} gelijk aan "base64" zou moeten worden geinterpreteerd als binary data.
    <div class=example>
        Dit veld zou moeten worden geinterpreteerd als binary data, zoals een SQL `VARBINARY`.
        <pre highlight="json">
            "hash": {
                "title": "hash",
                "description": "SHA512 hash",
                "type": "string",
                "contentEncoding": "base64"
            }
        </pre>
    </div>

    Wanneer een {{maxLength}} attribuut is meegegeven aan een `string` veld zou het veld moeten worden geinterpreteerd
    als een fixed width binary type zoals een SQL `BINARY`, met {{maxLength}}`=4*ceil(bytes/3)`.
    <div class=example>
        Dit veld zou moeten worden geinterpreteerd als fixed length binary data, zoals een SQL `BINARY`.
        <pre highlight="json">
            "hash": {
                "title": "hash",
                "description": "SHA512 hash",
                "type": "string",
                "contentEncoding": "base64",
                "maxLength": 88
            }
        </pre>
    </div>


### tijd ### {#data-types-time}
    Met het {{format}} attribuut kan een `string` veld worden geformatteerd als tijds of datum eenheid. Een `string` [=veld=] met een {{format}}
    gelijk aan `"time"`, `"date"`, `"date-time"` of `"duration"` zou moeten worden geinterpreteerd als een
    [[ISO8601]] conform Datum of tijd type zoals een SQL `DATE`, `TIME` of `DATETIME`.

    Note: De maximale precisie van de tijdseenheden is microseconde.

    Note: Bij een `"date-time"` wordt aangeraden om een tijdszone op te geven. Wanneer de tijdszone ontbreekt wordt een data-kwaliteit waarschuwing gegeven.

    <div class=example>
        Dit veld zou moeten worden geinterpreteerd als een [[ISO8601]] Datum type in het format YYYY-MM-DD, zoals een SQL `DATE`.
        <pre highlight="json">
            "publicatieDatum": {
                "title": "publicatie datum",
                "description": "Datum van publicatie",
                "type": "string",
                "format": "date"
            }
        </pre>
    </div>

    <div class=example>
        Dit veld zou moeten worden geinterpreteerd als een [[ISO8601]] conform tijd type, zoals een SQL `TIME`.
        <pre highlight="json">
            "publicatieTijd": {
                "title": "publicatie tijd",
                "description": "Tijd van publicatie",
                "type": "string",
                "format": "time"
            }
        </pre>
    </div>

    <div class=example>
        Dit veld zou moeten worden geinterpreteerd als een [[ISO8601]] conform datum-tijd type, zoals een SQL `DATETIME`.
        <pre highlight="json">
            "tijdEnDatumVanPublicatie": {
                "title": "Tijd en datum van publicatie",
                "description": "Tijd en datum van publicatie",
                "type": "string",
                "format": "date-time"
            }
        </pre>
    </div>

    <div class=example>
        Dit veld zou moeten worden geinterpreteerd als een [[ISO8601]] conform tijdsduur type, zoals een postgreSQL `INTERVAL`.
        <pre highlight="json">
            "duur": {
                "title": "Evenements duur",
                "description": "Tijdsduur dat het evenement open is voor publiek.",
                "type": "string",
                "format": "duration"
            }
        </pre>
    </div>


### geometrie ### {#geometry}
    Een geometrie veld wordt gedefinieerd als een verwijzing naar de relevante GeoJSON Schema definitie.
    Alle GeoJSON geometrie typen (*Point*, *Polygon*, *Line String*, *Multi Point*, *Multi LineString*,
    en *Multi Polygon*) worden ondersteund.

    <div class=example>
        Voorbeeld van een geometrie veld.
        <pre class="include-code">
            path: examples/datasets/bekendeAmsterdammers/pleinen/v1.json
            highlight: json
            show: 28-32
        </pre>
    </div>

    Een tabel schema mag meerdere geometrie velden bezitten.
    Bijvoorbeeld de contour van een object in een *Polygon* en de centrale coordinaten van het object in een *Point*.

    Doelsystemen die slechts één geometrie veld per object ondersteunen moeten gebruik maken van het veld waarnaar wordt
    verwezen in het {{mainGeometry}} attribuut van de [=tabel=]. Als de tabel geen expliciet {{mainGeometry}} attribuut heeft
    is dit de default waarde: `"Geometry"`.

    Note: Als een tabel één of meerdere geometrie velden heeft, maar geen van deze velden `"Geometry"` heet,
        **moet** één van de velden als primaire geometrie worden aangegeven in {{mainGeometry}}.

    Note: Als een tabel een geometrie veld bevat, moet op dataset niveau het coordinaat
    referentie systeem worden aangegeven in het {{dataset/crs}} attribuut.

    [HIDELINESEXAMPLE]
        Voorbeeld van een tabel met meerdere geometrie velden. Het veld `"locatie"` is hier als primaire geometrie
        aangegeven in "{{mainGeometry}}".
        <pre class="include-code">
            path: examples/datasets/bekendeAmsterdammers/pleinen/v1.json
            highlight: json
            line-highlight: 0-7,28-37
        </pre>
    [END]


### object ### {#data-types-object}
    Een [=veld=] van type `object` kan gestructureerde data (objecten of structs) bevatten.
    Een objectveld met het `format` `json` mag willekeurige JSON-data bevatten.
    Alle overige objectenvelden moeten een attribuut {{veld/properties}} bezitten
    waarin de structuur van de waarden in het veld wordt vastgelegd.
    Het {{veld/properties}} attribuut is een object met daarin de [=veld=] definities van de eigenschappen van de datawaarden.

    Note: Het {{veld/properties}} attribuut moet geen `object` of `array` [=veld|velden=] bevatten.
        Geneste data is in een gestructureerd object veld niet toegestaan.

    <div class=example>
        Een voorbeeld van een object veld.
        <pre highlight="json">
            "adres": {
                "title": "Adres",
                "description": "Het adres.",
                "type": "object",
                "properties": {
                    "functieAdres": {
                        "type": "string",
                        "title": "Functie adres",
                        "description": "Aanduiding van het soort adres. Mogelijke waarden: W (woonadres), B (briefadres).",
                        "enum": ["W", "B"]
                    },
                    "huisnummer": {
                        "type": "integer",
                        "exclusiveMaximum": 2147483648,
                        "minimum": 0

                    },
                    "toevoeging": {
                        "type": "string"
                    },
                    "postcode": {
                        "description": "Volledige postcode zonder spaties.",
                        "type": "string"
                        "minLength": 6,
                        "maxLength": 6
                    },
                    "straatnaam": {
                        "type": "string"
                    }
                }
            }
        </pre>
    </div>

    Note: De velden in {{veld/properties}} zijn altijd nullable.

    Als een `object` veld een {{veld/properties}} attribuut bevat (gestructureerd is), moet het in doelsystemen geinterpreteerd worden als een SQL `STRUCT` type.
    Als een `object` veld geen {{veld/properties}} attribuut heeft (ongestructureerd is) kan het in doelsystemen slechts ongeindexeerd worden opgeslagen in bijvoorbeeld een JSON string.

    Daarom moet het gebruik van `object` velden zonder {{veld/properties}} attribuut waar mogelijk worden vermeden.
    Een config/properties veld van string keys naar string waarden is een voorbeeld van acceptabel gebruik van een ongestructureerd `object` veld.


### array ### {#data-types-array}
    Een [=veld=] van type `array` kan meerdere elementen van hetzelfde type bevatten, met mogelijke duplicatie.
    Een `array` veld **moet** een {{veld/items}} attribuut hebben, dit **moet** een [=veld=] object zijn.

    Note: De optie van een {{veld/items}} array uit de [[json-schema-validation|JSON Schema specificatie]] wordt niet ondersteund.
        Een `array` kan dus slechts één type waarde bevatten (geen UNION types).

    Het {{veld/items}} attribuut is een [=veld=] object, maar de meta-data attributen {{veld/title}}, {{veld/description}}, {{veld/auth}}, {{veld/provenance}}, {{veld/shortname}} en {{veld/relation}} hebben in {{veld/items}} geen effect en zouden moeten worden weggelaten.

    Note: Een array van arrays is niet toegestaan. Dus {{veld/items}} mag zelf niet het type `array` hebben.

    <div class=example>
        Een array van integers.
        <pre highlight="json">
            "weeknummers": {
                "title": "weeknummers",
                "description": "Weeknummers.",
                "type": "array",
                "items": {
                    "type": "integer",
                    "exclusiveMaximum": 256,
                    "minimum": 0,
                }
            }
        </pre>
    </div>

    <div class=example>
        Een array van objecten.
        <pre highlight="json">
            "metingen": {
                "title": "metingen",
                "description": "Uitgevoerde metingen.",
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "meetonzekerheid": {
                            "title": "Meetonzekerheid",
                            "description": "Onzekerheid van de meting.",
                            "type": "number",
                            "minimum": 0
                        },
                        "waarde": {
                            "title": "Waarde",
                            "description": "De gemeten waarde.",
                            "type": "number"
                        }
                    }
                }
            }
        </pre>
    </div>

Issue: Het is onduidelijk of `unit` in een array moet worden meegegeven in het items attribuut  als `veld.items.unit` of in het hoofd object als `veld.unit`.


Relaties {#relatering}
-------------------------------
Met het {{relation}} attribuut van een [=veld=] kunnen relaties tussen tabellen worden gedefinieerd.
Dit kan zowel een relatie tussen tabellen in één dataset als tussen tabellen in verschillende datasets zijn.
Met het relation-attribuut wordt verwezen naar het identifierveld van de andere tabel.
Dit is vergelijkbaar met een foreign key relatie in SQL.

Het attribuut {{relation}} moet altijd een string bevatten
van de vorm `"<dataset-id>:<tabel-id>"`.
Van de waarden in een relation veld wordt verwacht dat ze gelijk zijn aan
de unieke identifier van een rij in de tabel waaraan gerefereerd wordt.

Note: Dit is niet verplicht, referentiële integriteit wordt niet afgedwongen.
    Het kan dus voorkomen dat relaties naar niet (meer) bestaande entiteiten verwijzen.

In het geval dat gerefereerd wordt aan een tabel zonder temporaliteit, moet het
type van het verwijzende veld overeenkomen met het type van de identifier
van de andere tabel.

<div class=example>
    Voorbeeld van een relatie veld voor een enkelvoudige relatie met de tabel "meetbouten" in de
    dataset "meetbouten".
    <pre highlight="json">
        "hoortBijMeetbout": {
            "title": "hoort bij meetbout",
            "description": "De meetbout waarop de meting is gedaan."
            "type": "string",
            "relation": "meetbouten:meetbouten"
        }
    </pre>
</div>

Als gerefereerd wordt aan een tabel met temporaliteit, bestaat de unieke identifier van
een object in die tabel uit twee velden; de tabel identifier en de temporele identifier
(zie [[#temporaliteit]]). In dit geval moet het verwijzende veld van het type `object` zijn
en twee `properties` bevatten, met namen en types die overeenkomen met de `identifier`
en de `temporal` van het object waarnaar verwezen wordt.

<div class=example>
    Voorbeeld van een relatie veld voor een enkelvoudige relatie met de temporele tabel "wijken" in de
    dataset "gebieden".
    <pre highlight="json">
        "ligtInWijk": {
            "title": "ligt in wijk",
            "description": "De wijk waar de buurt in ligt.",
            "type": "object",
            "relation": "gebieden:wijken",
            "properties": {
                "identifier": {
                    "type": "string"
                },
                "volgnummer": {
                    "type": "string"
                }
            }
        }
    </pre>
</div>

Voor meervoudige (Many-To-Many) relaties wordt een [[#data-types-array| array]] veld gebruikt met een relation attibuut.

<div class=example>
    Voorbeeld van een relatieveld voor een meervoudige relatie met de tabel "referentiepunten"
    in de dataset "meetbouten".
    <pre highlight="json">
        "refereertAanReferentiepunten": {
            "shortname": "referentiepunten",
            "title": "refereert aan referentiepunten",
            "description": "De referentiepunten waar aan de meetbout refereert.",
            "type": "array",
            "relation": "meetbouten:referentiepunten",
            "items": {
                "type": "string"
            }
        }
    </pre>
</div>

<div class=example>
    Voorbeeld van een relatieveld voor een meervoudige relatie met een temporele tabel "panden"
    in de dataset "bag".
    <pre highlight="json">
        "ligtInPanden": {
            "title": "ligt in panden",
            "relation": "bag:panden",
            "description": "De unieke landelijke aanduidingen van de panden waarvan het verblijfsobject onderdeel uitmaakt.",
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "identificatie": {
                        "type": "string"
                    },
                    "volgnummer": {
                        "type": "integer"
                    }
                }
            }
        }
    </pre>
</div>


Eenheden {#units}
---------------------------

Het is mogelijk om bij een veld de eenheid mee te geven in het {{veld/unit}} attribuut als meta-informatie voor user interfaces.
Dit is slechts bedoeld ter informatie van de eindgebruiker,
er worden dus geen automatische bewerkingen (zoals bijvoorbeeld eenheid conversies) uitgevoerd op basis van dit veld.

Voor het definieren van een eenheid wordt standaard een string met de eenheid volgens de [[!UCUM inline]] codering gebruikt.

<pre class=example highlight=json>
    "unit": "mm/h"
</pre>

Note: Zie [deze link](https://ucum.org/trac/wiki/adoption/common) voor een overzicht van veelgebruikte eenheden in UCUM-format.

Voor valuta's wordt de drieletterige codering [ISO 4217](https://en.wikipedia.org/wiki/ISO_4217) gebruikt
binnen een [UCUM 2.1§6](https://ucum.org/ucum.html#section-Character-Set-and-Lexical-Rules) unitannotatie.
<pre class=example highlight=json>
    "unit": "{EUR}/h"
</pre>

De eenheidscodering kan ook expliciet meegegeven worden door {{veld/unit}} een `object` mee te geven.
Een {{veld/unit}} object moet de volgende attributen bevatten.
<table dfn-type="attribute" dfn-for=unit export class="dfn-table">
    <tr><td><dfn>type</dfn>       <td> string <td> de eenheidscodering
    <tr><td><dfn>value</dfn>      <td> string <td> de eenheid
</table>

<pre class=example highlight=json>
    "unit": {"type": "ucum", "value": "{EUR}/h"}
</pre>

Zo kunnen ook andere eenheidscoderingen gebruikt worden.
<pre class=example highlight=json>
"unit": {"type": "pint", "value": "meter"}
</pre>

[BP]
    Gebruik de UCUM-standaard om eenheden te coderen. Niet-standaard-coderingssystemen worden afgeraden.
[BPE]


<!--
██    ██    ███       ███    ██     ██  ██████   ████████ ██     ██ ████ ██    ██  ██████
███   ██   ██ ██     ██ ██   ███   ███ ██    ██  ██       ██     ██  ██  ███   ██ ██    ██
████  ██  ██   ██   ██   ██  ████ ████ ██        ██       ██     ██  ██  ████  ██ ██
██ ██ ██ ██     ██ ██     ██ ██ ███ ██ ██   ████ ██████   ██     ██  ██  ██ ██ ██ ██   ████
██  ████ █████████ █████████ ██     ██ ██    ██  ██        ██   ██   ██  ██  ████ ██    ██
██   ███ ██     ██ ██     ██ ██     ██ ██    ██  ██         ██ ██    ██  ██   ███ ██    ██
██    ██ ██     ██ ██     ██ ██     ██  ██████   ████████    ███    ████ ██    ██  ██████
-->
Naamgeving {#naamgeving}
====================================
De data die in Amsterdam Schema wordt beschreven wordt publiek ontsloten en heeft veel externe afnemers. Het is
dus heel belangrijk dat naamgeving correct, helder en eenduidig is, ook voor mensen die niet dagelijks met deze gegevens werken.
Amsterdam Schema is ontworpen om door automatische systemen verwerkt te kunnen worden, ook daarom is het belangrijk dat de naamgeving
aan een strak stramien voldoet.

Namen van [=datasets=], [=tabel|tabellen=] en [=veld|velden=] **moeten**:
<ul style="list-style: none;">
    <li><dfn lt="camelCase" export>1.</dfn> gebruik maken van camelCase.</li>
    <li><dfn lt="noAbrev" export>2.</dfn> geen afkortingen of afbrekingen bevatten.</li>
    <li><dfn lt="nouns" export>3.</dfn> bestaan uit zelfstandige naamwoorden (met uitzondering van de namen van relatievelden).</li>
    <li><dfn lt="unique" export>4.</dfn> uniek zijn binnen hun scope. (respectievelijk: De hele catalogus, de dataset of de tabel)</li>
</ul>
De namen van [=tabel|tabellen=] (zoals gegeven in {{tabel/id}}) en [=veld|velden=]
worden onderdeel van de URI waarop deze entiteiten ontsloten worden, en moeten daarom aan extra eisen voldoen.

<dfn lt="plural" export>5.</dfn> Namen van tabellen **moeten** in meervoudsvorm zijn, behalve als sprake is van een enkelvoudige entiteit. Conform [[REST-API-DESIGN-RULES#api-54]].

<dfn lt="noRepeat" export>6.</dfn> Namen van velden **moeten** geen herhaling van de tabel naam bevatten. (Dus **niet** `container.containerNummmer`, maar `container.nummer`.)

Note: Gebruik duidelijke en begrijpelijke namen voor zowel datasets, tabellen als velden. De data wordt onsloten op een publieke API,
    dus de naamgeving moet zonder veel uitleg duidelijk zijn voor externe afnemers.


Shortname {#shortname}
----------------------------------------
Te lange namen in het schema kunnen problemen geven bij het aanmaken van tabellen en kolommen op basis van het schema.
PostgreSQL staat bijvoorbeeld niet meer dan 63 tekens toe voor tabelnamen.

Op zowel [=tabel=] als [=veld=] niveau is het mogelijk om een alternatieve verkorte naam op te geven met het attribuut `shortname`.
Het shortname attribuut mag wel afkortingen bevatten ([=noAbrev|regel 2=] geldt niet) maar moet verder aan dezelfde eisen voldoen als de naam die erdoor wordt afgekort.

<div class=example>
    Gebruik van shortname in een tabel.
    <pre highlight=json>
        {
            "id": "maatschappelijkeActiviteiten",
            "shortname": "activiteiten",
            "type": "table"
            ...
        }
    </pre>
</div>

<div class=example>
    Gebruik van shortname in een veld.
    <pre highlight=json>
        "registratieTijdstipMaatschappelijkeActiviteit": {
            "shortname": "registratieTijdstip",
            "type": "string",
            "format": "date-time"
        }
    </pre>
</div>


<!--
████████  ██     ██ ████████  ██       ████  ██████  ██     ██ ████████ ████████   ██████
██     ██ ██     ██ ██     ██ ██        ██  ██    ██ ██     ██ ██       ██     ██ ██    ██
██     ██ ██     ██ ██     ██ ██        ██  ██       ██     ██ ██       ██     ██ ██
████████  ██     ██ ████████  ██        ██   ██████  █████████ ██████   ████████   ██████
██        ██     ██ ██     ██ ██        ██        ██ ██     ██ ██       ██   ██         ██
██        ██     ██ ██     ██ ██        ██  ██    ██ ██     ██ ██       ██    ██  ██    ██
██         ███████  ████████  ████████ ████  ██████  ██     ██ ████████ ██     ██  ██████
-->
Publisher {#publishers}
======================================================

Een [=publisher=] definitie bevat een publisher object. Deze word onder andere gebruikt voor billing en tagging
van resources die via het amsterdam schema worden aangevraagd.

<div class=example>
    Voorbeeld van een publisher object.
    <pre highlight="json">
    {
      "id": "NOBODY",
      "type": "publisher"
      "name": "Datateam Nobody",
      "shortname": "nobody",
      "tags": {
        "costcenter": "00000000.0000"
        "team": "nobody",
      },
    }
    </pre>
</div>

Verplichte attributen {#publisher-mandatory-fields}
---------------------------------------------------------
Een <dfn dfn export>publisher</dfn> binnen Amsterdam Schema is een JSON object met in ieder geval de volgende attributen.
<table dfn-type="attribute" dfn-for=publisher export class="dfn-table">
    <tr><td><dfn>id</dfn>       <td> {{id-type|identifier}} <td> Identifier van de publisher. Moet globaal uniek zijn en gelijk aan de file waarin het publisher object is opgeslagen.
    <tr><td><dfn>type</dfn>     <td> constante <td> Type van dit bestand, in dit geval `"publisher"`.
    <tr><td><dfn>name</dfn>     <td> string <td> Naam van de publisher.
    <tr><td><dfn>shortname</dfn>     <td> {{resource-identifier}} <td> Verkorte naam van de publisher (voor resources).
    <tr><td><dfn>tags</dfn>   <td> object
        <td> Labels met metagegevens die aan resources van deze publisher moeten worden gehangen.
            <details>
                <summary>Valide elementen</summary>
                    <table class="dfn-table">
                        <tr><td><dfn>costcenter</dfn> <td> **REQUIRED**       <td> string <td> Costcenter tag van de publisher
                        <tr><td><dfn>team</dfn> <td>      <td> string <td> Team tag van de publisher
                    </table>
            </details>
</table>

<!--
 ███▌   ███▌   ███▌  ████▌  █████▌  ███▌
█▌  █▌ █▌  █▌ █▌  █▌ █▌  █▌ █▌     █▌  █▌
█▌     █▌     █▌  █▌ █▌  █▌ █▌     █▌
 ███▌  █▌     █▌  █▌ ████▌  ████    ███▌
    █▌ █▌     █▌  █▌ █▌     █▌         █▌
█▌  █▌ █▌  █▌ █▌  █▌ █▌     █▌     █▌  █▌
 ███▌   ███▌   ███▌  █▌     █████▌  ███▌
-->
Scope {#scopes}
===========================

Een <dfn export>scope</dfn> is een groep gebruikers (medewerkers) met gedeelde rechten. Een gebruiker kan meerdere scopes hebben.
Een scope is een string bestaande uit een reeks lower of uppercase letters eventueel gescheiden door een forward slash (`/`),
bijvoorbeeld `"BRP/RO"`.

In versie 2.1.0 van het metaschema is de mogelijkheid toegevoegd om een scope in een apart bestand te definieren. Dit is
in versie 2.2.0 uitgebreid met velden waar een Azure access package kan worden gespecificeerd voor
de verschillende omgevingen. Deze bestanden bevinden zich in de scopes/<team> folders.

<div class=example>
    Voorbeeld van een scope object.
    <pre highlight="json">
        {
            "type": "scope",
            "id": "LEVEL/X",
            "naam": "Toegang tot level X",
            "accessPackages": {
                "production": "EM4W-DATA-schemascope-p-scope_level_x",
                "nonProduction": "EM4W-DATA-schemascope-ot-scope_level_x"
            },
            "owner": {
                "$ref": "publishers/BENK
            }
        }
    </pre>
</div>

Verplichte attributen {#scope-mandatory-fields}
---------------------------------------------------------
Een scope binnen Amsterdam Schema is een JSON object met in ieder geval de volgende attributen.
<table dfn-type="attribute" dfn-for=scope export class="dfn-table">
    <tr><td><dfn>id</dfn>                   <td> {{id-type|identifier}} <td> Identifier van de scope. Moet globaal uniek zijn, maar kan afwijken van de bestandsnaam, omdat scopes vaak een '/' bevatten.
    <tr><td><dfn>type</dfn>                 <td> "scope" <td> Type van dit bestand, altijd de constante `"scope"`.
    <tr><td><dfn>name</dfn>                 <td> string <td> Naam van de scope.
    <tr><td><dfn>accessPackages</dfn>       <td> object <td> De access packages voor verschillende omgevingen.
    <tr><td><dfn>owner</dfn>                <td> object <td> Referentie naar de eigenaar van de scope.
            <details>
                <summary>Verplichte referentie</summary>
                    <table class="dfn-table">
                        <tr><td><dfn>$ref</dfn> <td> **REQUIRED**       <td> string <td> Referentie naar de publisher/owner van de dataset.
                    </table>
            </details>
</table>

<!--
   ███    ██     ██ ████████  ███████  ████████  ████  ██████     ███    ████████ ████ ████████
  ██ ██   ██     ██    ██    ██     ██ ██     ██  ██  ██    ██   ██ ██      ██     ██  ██
 ██   ██  ██     ██    ██    ██     ██ ██     ██  ██  ██        ██   ██     ██     ██  ██
██     ██ ██     ██    ██    ██     ██ ████████   ██   ██████  ██     ██    ██     ██  ██████
█████████ ██     ██    ██    ██     ██ ██   ██    ██        ██ █████████    ██     ██  ██
██     ██ ██     ██    ██    ██     ██ ██    ██   ██  ██    ██ ██     ██    ██     ██  ██
██     ██  ███████     ██     ███████  ██     ██ ████  ██████  ██     ██    ██    ████ ████████
-->
Autorisatie {#autorisatie}
======================================================

Confirm the [[Woo|Wet Open Overheid]] (Woo) zijn gegevens standaard openbaar.
Er zijn twee mechanismen om de toegang te beperken en authorisatie in te regelen:

1. De `"auth"`-attributen in het Amsterdam-schema beperken de toegang. zie [[#auth-attributes]].
2. De profielen geven granulair toegang op basis van een gebruikersprofiel. zie [[#profielen]].

Beide mechanismen gebruiken doorvoor scopes om te koppelen met gebruikersgroepen in de bestaande architectuur.
Deze scopes worden bijvoorbeeld verkregen vanuit een bestaande OAuth-flow die een JSON Web Token (JWT) aanbiedt.

Auth-attributen {#auth-attributes}
---------------

Op zowel [=dataset=], [=tabel=] als [=veld=] niveau kan een `"auth"`-attribuut worden meegegeven om toegang tot een entitieit te beperken.
<table export class="dfn-table">
    <tr><td><dfn>auth</dfn> <td> string | array | scope-$ref <td> geautoriseerde [=scope|scope(s)=].
    <tr><td><dfn>reasonsNonPublic</dfn>  <td> array({{nonPubReason}})
        <td> een of meer gronden voor het niet openbaar maken van data obv uitzonderingen in Hoofdstuk 5 van de [[Woo]].
             Verplicht op het eerste niveau waar de `"auth"` niet gelijk is aan `"OPENBAAR"`.
</table>

Het `"auth"`-attribuut bevat één of meer scopes, die leesrechten hebben op de entiteit waarop `"auth"` is gedefinieerd.

### Meerdere scopes {#auth-multiple-scopes}

Als het `"auth"`-attribuut een array bevat is elke scope in de array afzonderlijk geautoriseerd.
Dus een gebruiker heeft slechts één van de [=scopes=] in een array nodig voor toegang.

<div class=example>
    Voorbeeld van een `"auth"` array op een veld.
    Zowel scope `"LEVEL/X"` als scope `"LEVEL/Y"` toegang tot het veld. Een gebruiker hoeft niet beide scopes te bezitten.
    <pre highlight="json">
        "aantalDuivenOpDeDam": {
            "title": "aantal duiven op de Dam",
            "description": "Het gemeten aantal duiven op de de Dam",
            "auth": ["LEVEL/X", "LEVEL/Y"]
            "type": "integer"
        }
    </pre>
</div>

Een [=scope=] kan op deze manier in een auth veld worden gebruikt:
<div class=example>
    Voorbeeld van een `"auth"` dat verwijst naar een scope.
    <pre highlight="json">
        "aantalDuivenOpDeDam": {
            "title": "aantal duiven op de Dam",
            "description": "Het gemeten aantal duiven op de de Dam",
            "auth": {
                "$ref": "scopes/BENK/LEVEL-X
            },
            "type": "integer"
        }
    </pre>
</div>

Het is ook mogelijk om een array van scopes mee te geven:
<div class=example>
    Voorbeeld van een `"auth"` dat verwijst naar een array met scopes.
    <pre highlight="json">
        "aantalDuivenOpDeDam": {
            "title": "aantal duiven op de Dam",
            "description": "Het gemeten aantal duiven op de de Dam",
            "auth": [
                {
                    "$ref": "scopes/BENK/LEVEL-X
                },
                {
                    "$ref": "scopes/BOR/LEVEL-Y
                }
            ],
            "type": "integer"
        }
    </pre>
</div>

### Meerdere niveau's {#auth-multiple-levels}

Op dataset niveau is het {{dataset/auth}} attribuut verplicht.
Bij een openbare [=dataset=] krijgt het {{dataset/auth}} attribuut de waarde `"OPENBAAR"`.

Als een [=tabel=] geen `"auth"` attribuut heeft, is de scope van de [=tabel=] gelijk aan die van de dataset.

Als een [=veld=] geen `"auth"` attribuut heeft, is de scope van het [=veld=] gelijk aan die van de tabel.

Om toegang tot een veld te krijgen, moet de gebruiker op alle niveau's toegang krijgen; op veld-, tabel- en datasetniveau.

Op het eerste niveau waarop data niet openbaar wordt gemaakt moet een `"reasonsNonPublic"`-attribuut bestaan.
Dus als een dataset openbaar is, maar deze een tabel bevat waarop een {{tabel/auth}} attribuut met een andere waarde dan "OPENBAAR" bestaat.
Moet in de betreffende tabel of tabellen een {{tabel/reasonsNonPublic}} attribuut bestaan.

<div class=example>
In dit voorbeeld vindt autorisatie plaats op 3 niveaus.
Scope `"LEVEL/A"` heeft dataset level autorisatie op gebieden, scope `"LEVEL/B"` heeft tabel level autorisatie op bouwblokken en scope `"LEVEL/C"` heeft autorisatie op veld beginGeldigheid.

    * Een user met scope `"LEVEL/A"` mag alles uit de dataset `gebieden` zien, behalve tabel `bouwblokken`.
    * Een user met scope `"LEVEL/A"` en `"LEVEL/B"` mag alle velden van tabel `bouwblokken` zien, behalve `beginGeldigheid`.
    * Een user met scope `"LEVEL/A"` en `"LEVEL/B"` en `"LEVEL/C"` mag het veld `beginGeldigheid` ook zien.

    <pre highlight="json" line-highlight=5,17,39>
        {
            "type": "dataset",
            "id": "gebieden",
            "title": "gebieden",
            "auth": "LEVEL/A",
            "reasonsNonPublic": [
                "5.1 1b: Gevaar voor staatsveiligheid"
            ],
            "status": "beschikbaar",
            "crs": "EPSG:28992",
            "tables": [
                {
                    "id": "bouwblokken",
                    "mainGeometry": "geometrie",
                    "type": "table",
                    "version": "1.0.0",
                    "auth": "LEVEL/B",
                    "schema": {
                        "$id": "https://github.com/Amsterdam/schemas/gebieden/bouwblokken.json",
                        "$schema": "http://json-schema.org/draft-07/schema#",
                        "type": "object",
                        "additionalProperties": false,
                        "identifier": ["id"],
                        "required": ["schema", "id"],
                        "display": "id",
                        "properties": {
                            "schema": {
                                "$ref": "https://schemas.data.amsterdam.nl/schema@v1.1.1#/definitions/schema"
                            },
                            "id": {
                                "type": "string",
                                "description": "Unieke identificatie voor dit object, inclusief volgnummer"
                            },
                            "beginGeldigheid": {
                                "type": "string",
                                "format": "date",
                                "title": "Begin geldigheid",
                                "description": "De datum waarop het object is gecreëerd.",
                                "auth": "LEVEL/C"
                            },
                            "eindGeldigheid": {
                                "type": "string",
                                "format": "date",
                                "title": "Eind geldigheid",
                                "description": "De datum waarop het object is komen te vervallen.",
                                "provenance": "eindgeldigheid"
                            },
                            "ligtInBuurt": {
                                "type": "string",
                                "relation": "gebieden:buurten",
                                "provenance": "ligtinbuurt",
                                "title": "Ligt in buurt",
                                "description": "De buurt waar het bouwblok in ligt."
                            }
                        }
                    }
                }
            ]
        }
    </pre>
</div>

Profielen {#profielen}
---------------------------------------------------

Waar een `"auth"`-attribuut de toegang ontzegt, geeft een profiel granulair toegang onder voorwaarden.
Een profiel wordt alleen toegepast als er geen authorisatie verkregen is via de `"auth"`-attributen.

<div class=example>
    Voorbeeld van een profiel, wat het functieprofiel "parkeerwachter" toegang geeft tot "parkeervakken".
    <pre highlight="json">
        {
            "id": "parkeerwachter",
            "type": "profile",
            "name": "Parkeerwacht toegang",
            "scopes": ["FP/PARKEERWACHTER"],
            "datasets": {
                "parkeervakken": {
                    "tables": {
                        "parkeervakken": {
                            "permissions": "read",
                        }
                    }
                }
            }
        }
    </pre>
</div>

<div class=example>
    Voorbeeld an een profiel wat interne gegevenssets beschikbaar stelt.
    <pre highlight="json">
        {
            "name": "medewerker",
            "scopes": ["FP/MDW"],
            "datasets": {
                "blackspots": {"permissions": "read"},
                "wior": {"permissions": "read"},
                "ondergrond": {"permissions": "read"},
                "meldingen": {"permissions": "read"},
                "huishoudelijkafval": {
                    "tables": {
                        "planningvoertuigen": {"permissions": "read"}
                    }
                },
                "leidingeninfrastructuur": {
                    "tables": {
                        "liggingPuntTotaal": {"permissions": "read"},
                        "liggingVlakTotaal": {"permissions": "read"},
                        "liggingLijnTotaal": {"permissions": "read"}
                    }
                }

            }
        }
    </pre>
</div>

Een profiel kan toegang geven op dataset-, tabel- en veldniveau.
Daarbij kan ook een zoekvraag (`"mandatoryFilterSets"`) verplicht zijn om toegang te krijgen.

<div class=example>
    Voorbeeld van een profiel wat slechts toegang geeft tot een paar velden, en een zoekvraag verplicht.
    <pre highlight="json">
        {
            "id": "parkeerwachter",
            "type": "profile",
            "name": "Parkeerwacht toegang beperkt",
            "scopes": ["FP/PARKEERWACHTER-B"],
            "datasets": {
                "parkeervakken": {
                    "tables": {
                        "parkeervakken": {
                            "fields": {
                                "type": "read",
                                "grootte": "read",
                                "opmerking": "letters:10",
                            },
                            "mandatoryFilterSets": [
                                ["id", "volgnummer"],
                                ["buurtcode", "type"],
                            ],
                        }
                    }
                }
            }
        }
    </pre>
</div>

Verplichte attributen {#profile-mandatory-fields}
---------------------------------------------------------
Een <dfn dfn export>profiel</dfn> binnen Amsterdam Schema is een JSON object met in ieder geval de volgende attributen.

<table dfn-type="attribute" dfn-for=profiel export class="dfn-profile">
    <tr><td style="min-width: 10em"><dfn>id</dfn>       <td style="min-width: 5em"> {{id-type|identifier}} <td> Identifier van de publisher. Moet globaal uniek zijn en gelijk aan de file waarin het publisher object is opgeslagen.
    <tr><td><dfn>type</dfn>     <td> constante <td> Type van dit bestand, in dit geval `"profile"`.
    <tr><td><dfn>name</dfn>     <td> string <td> Naam van het gebruikersprofiel.
    <tr><td><dfn>scopes</dfn>   <td> {{resource-identifier}} <td> De geautoriseerde [=scope|scope(s)=] die de gebruiker moet hebben om dit profiel te activeren.
    <tr><td><dfn>datasets</dfn> <td> object <td> Mapping van alle datasets, waarbij iedere sleutel verwijst naar het `id` van een [=dataset=].
</table>

Iedere *dataset* in een profiel kan de volgende waarden bevatten:

<table dfn-type="attribute" dfn-for=profiledataset export class="dfn-profiledataset">
    <tr><td style="min-width: 10em"><dfn>permissions</dfn> <td style="min-width: 5em"> string <td> De waarde `"read"` voor leestoegang.
    <tr><td><dfn>tables</dfn>      <td> object <td> Een mapping van tabellen, waarbij iedere sleutel verwijst naar het `id` van een [=tabel=].
</table>

Iedere *tabel* in een profiel kan over de volgende waarden bevatten:

<table dfn-type="attribute" dfn-for=profiletable export class="dfn-profiletable">
    <tr><td style="min-width: 10em"><dfn>permissions</dfn> <td style="min-width: 5em"> string <td> De waarde `"read"` voor leestoegang.
    <tr><td><dfn>fields</dfn>              <td> object <td> Een mapping van velden, waarbij iedere sleutel verwijst naar het `id` van een [=veld=].
    <tr><td><dfn>mandatoryFilterSets</dfn> <td> array  <td> Een array van tuples met verplichte zoekvelden.
</table>

Ieder *veld* in een profiel kan over de volgende waarden bevatten:

<table dfn-type="attribute" dfn-for=profilefield export class="dfn-profilefield">
    <tr><td style="min-width: 10em"><dfn>permissions</dfn> <td style="min-width: 5em"> string <td> Het toegangsniveau tot het veld.
       Mogelijke waarden: `"read"` voor leestoegang,
       `"letters:##"` geeft toegang tot de eerste aantal karakters van het veld.
</table>

### Verplichte zoekvragen {#mandatory-filter-sets}

De <dfn export>mandatoryFilterSets</dfn> verplicht het gebruik van een zoekvraag om de tabel te raadplegen.
De waarde bevat een lijst van mogelijke toegestane vragen.
Operatoren zijn alleen toegestaan als deze letterlijk opgegeven worden, bijvoorbeeld `"regimes.aantal[gte]"`.

<div class=example>
    Voorbeeld van verplicht zoeken op id+volgnummer óf buurtcode+type.
    In een REST API betekend dit bijvoorbeeld dat de resource alleen inzichtelijk is
    met de zoekvraag `?id=...&amp;volgnummer=...` óf `?buurtcode=...&amp;type=...`.

    <pre highlight="json">
        "mandatoryFilterSets": [
            ["id", "volgnummer"],
            ["buurtcode", "type"]
        ]
    </pre>
</div>

### Toegangsregels {#access-rules}

Een gebruiker heeft toegang tot een [=dataset=] indien deze:

* Toegang krijgt via de `"auth"` regel.
* Of een profiel heeft met `"permissions": "read"` op dataset niveau.

Een gebruiker heeft toegang tot een [=tabel=] indien deze:

* Toegang krijgt via `"auth"` regels op de tabel én dataset.
* Of volledige toegang heeft tot de dataset door middel van een profiel met `"permissions": "read"` op dataset niveau.
* Of een profiel heeft met `"permissions": "read"` op tabel niveau, én voldoet aan de [=mandatoryFilterSets=] indien deze aanwezig zijn.
    Toegang tot het openen van dataset wordt daarmee impliciet verkregen.

Een gebruiker heeft toegang tot een [=veld=] indien deze:

* Toegang krijgt via `"auth"` regels op de dataset, tabel én het veld.
* Of volledige toegang heeft tot de dataset door middel van een profiel met `"permissions": "read"` op dataset niveau.
* Of volledige toegang heeft tot een tabel door middel van een profiel heeft met `"permissions": "read"` op het tabel niveau, waarbij de de [=mandatoryFilterSets=] voldaan zijn indien deze aanwezig zijn.
* Of een profiel heeft met `"permissions"` op het veld niveau, én voldoet aan de [=mandatoryFilterSets=] vam de tabel indien deze aanwezig zijn.
    Toegang tot het openen van de dataset en tabel wordt daarmee impliciet verkregen.


<!--
   ███    ████████ ████████ ████████  ████ ████████  ██     ██ ████████ ████████  ██████
  ██ ██      ██       ██    ██     ██  ██  ██     ██ ██     ██    ██    ██       ██    ██
 ██   ██     ██       ██    ██     ██  ██  ██     ██ ██     ██    ██    ██       ██
██     ██    ██       ██    ████████   ██  ████████  ██     ██    ██    ██████    ██████
█████████    ██       ██    ██   ██    ██  ██     ██ ██     ██    ██    ██             ██
██     ██    ██       ██    ██    ██   ██  ██     ██ ██     ██    ██    ██       ██    ██
██     ██    ██       ██    ██     ██ ████ ████████   ███████     ██    ████████  ██████
-->
Generieke attributen {#gen-attributes}
===================================================
Deze attributen kunnen op elk niveau bestaan.

Omschrijving {#omschrijving}
---------------------------------------------------

Op elk niveau kan een semantische omschrijving toegevoegd worden d.m.v. de attributen `title` en `description`.
<table dfn-type="attribute" export class="dfn-table">
    <tr><td> title       <td> (string) <td> Naam van dit item.
    <tr><td> description <td> (string) <td> Beschrijving van dit item, vrije tekst. Mag escape characters zoals newlines bevaten.
</table>

De `title` kan bijvoorbeeld in frontendapplicaties worden gebruikt als label voor een invoerveld.
Het `description` veld is bedoeld voor bijvoorbeeld contextmenu's (mouseover) bij een invoerveld of voor informatievelden.

<div class=example>
    `title` en `description` van een [=Dataset=].
    <pre class=include-code>
        path: examples/datasets/bekendeAmsterdammers/dataset.json
        highlight: json
        show: 4-5
    </pre>
</div>

<div class=example>
    `title` en `description` van een [=Tabel=].
    <pre class=include-code>
        path: examples/datasets/bekendeAmsterdammers/locaties/v1.json
        highlight: json
        show: 4-5
    </pre>
</div>

<div class=example>
    `title` en `description` in een [=Veld=].
    <pre class=include-code>
        path: examples/datasets/bekendeAmsterdammers/locaties/v1.json
        highlight: json
        show: 44-45
    </pre>
</div>

Note: Als een [=veld=] geen {{veld/title}}-attibuut heeft, wordt de naam van het veld gebruikt.


Provenance {#provenance}
------------------------------------------------------

Provenance als veld wordt gebruikt om programmatisch informatie op te slaan over de oorsprong van bepaalde data.

In beperkte vorm kan provenance ook gebruikt worden om automatisch verwerking van brongegevens in andere formaten te bewerkstelligen.

Provenance is beschikbaar op zowel dataset-, tabel- als veld-niveau. Het is een vrij veld maar door een object met 'type' te specificeren kunnen specifieke machine readable profielen geactiveerd worden t.b.v. automatische bronverwerking

### Vrije invoer ### {#provenance-vrije-invoer}

Dataset: `"provenance": "Deze dataset wordt handmatig verwerkt door ..."`

Tabel: `"provenance": "Deze tabel is gebaseerd op een CSV bestand aangeleverd door ..."`

Veld: `"provenance": "Ontbrekende IDs zijn m.b.v TextEdit vervangen door UUID hashes van de naam in UTF-8."`

### Postgres ### {#provenance-postgres}

Dataset: `"provenance": { "type": "postgres", "schema": "ruimte" }`

Tabel: `"provenance": { "table": "verhardingen" }`

Veld: `"provenance": { "field": "lengte_m", "type": "NUMERIC(10,2)"}`

### Shapefile ### {#provenance-shapefile}

Dataset: `"provenance": { "type": "shapefile"}`

Tabel: `"provenance": { "file": "asbestdaken_daken.zip" }`

Veld: `"provenance": { "field": "perceel_id"}`


<!--
████████ ██    ██ ████████  ████████  ██████
   ██     ██  ██  ██     ██ ██       ██    ██
   ██      ████   ██     ██ ██       ██
   ██       ██    ████████  ██████    ██████
   ██       ██    ██        ██             ██
   ██       ██    ██        ██       ██    ██
   ██       ██    ██        ████████  ██████
-->
Attribuuttypen {#attr-types}
==================================================
<table class="dfn-table">
    <tr><td><dfn typedef export lt=id|id-type>identifier</dfn>
        <td> string
        <td> Een unieke identifier in de vorm van één of meer letters, startend met een kleine letter en eventueel gevolgd door een cijferreeks.
    <tr><td><dfn typedef export lt=resource-identifier|resource-identifier-type>resource-identifier</dfn>
        <td> string
        <td> Een unieke identifier in de vorm van één tot en met twaalf kleine letters.
    <tr><td><dfn typedef export>date-time</dfn>
        <td> (string)
        <td> Een als datetime geformatteerde string. Conform [[json-schema-validation#rfc.section.7.3.1]].
    <tr><td><dfn typedef lt=uri|uri-type export>uri</dfn>
        <td> (string)
        <td> Een als URI geformatteerde string. Conform [[json-schema-validation#rfc.section.7.3.5]].
        <tr><td><dfn typedef export>uri-reference</dfn>
        <td> (string)
        <td> Een als URI Reference geformatteerde string. Conform [[json-schema-validation#rfc.section.7.3.5]].
    <tr><td><dfn typedef export lt=type|schema-type>schema-type</dfn>
        <td> (enum-string)
        <td> Het binnen Amsterdam Schema bekende [[!JSON-SCHEMA inline]] type waaraan het object voldoet.
            <details open>
                <summary>Opties</summary>
                    * "dataset"
                    * "table"
                    * "publisher"
                    * "scope"
            </details>
    <tr><td><dfn typedef export lt=nonPubReason>reden-niet-publiek</dfn>
        <td> (enum-string)
        <td> Grond voor het niet openbaar maken van data op basis van de uitzonderingen in Hoofdstuk 5 van de [[Woo|Wet Open Overheid]] (Woo).

            Met `"5.1 1a"`, wordt bedoeld Wet Open Overheid Artikel 5.1, eerste lid, onderdeel a.
            De beschrijvingen volgend op de wetsverwijzing zijn niet volledig en dienen slechts ter illustratie.
            Kijk voor de exacte definitie van een uitzondering in hoofdstuk 5 van de Woo.
        <details open>
            <summary>Opties</summary>
                * "5.1 1a: Gevaar voor eenheid van de Kroon"
                * "5.1 1b: Gevaar voor staatsveiligheid"
                * "5.1 1c: Vertrouwelijke of concurrentiegevoelige bedrijfs- en fabricagegegevens"
                * "5.1 1d: Bevat persoonsgegevens"
                * "5.1 1e: Bevat nationaal identificatienummer"
                * "5.1 2a: Zwaarwegend belang: internationale betrekkingen"
                * "5.1 2b: Zwaarwegende economische of financiële belangen van publiekrechtelijke lichamen (bevat geen milieu-informatie)"
                * "5.1 2b: Zwaarwegende economische of financiële belangen van publiekrechtelijke lichamen (bevat milieu-informatie met betrekking op handelingen met een vertrouwelijk karakter)"
                * "5.1 2c: Zwaarwegend belang: opsporing en vervolging van strafbare feiten"
                * "5.1 2d: Zwaarwegend belang: inspectie, controle en toezicht door bestuursorganen"
                * "5.1 2e: Zwaarwegend belang: eerbiediging van de persoonlijke levenssfeer"
                * "5.1 2f: Zwaarwegend belang: vertrouwelijke of concurrentiegevoelige bedrijfs- en fabricagegegevens"
                * "5.1 2g: Zwaarwegend belang: bescherming van het milieu waarop deze informatie betrekking heeft"
                * "5.1 2h: Zwaarwegend belang: beveiliging van personen en bedrijven en het voorkomen van sabotage"
                * "5.1 2i: Zwaarwegend belang: het goed functioneren van de Staat, andere publiekrechtelijke lichamen of bestuursorganen"
                * "5.2 1: Bevat persoonlijke beleidsopvattingen (bevat geen milieu-informatie)"
                * "5.2 4: Zwaarwegend belang: persoonlijke beleidsopvattingen (bevat milieu-informatie)"
                * "nader te bepalen"
        </details>
        De laatste optie ("nader te bepalen") is niet toegestaan wanneer {{versie/status}}=`"beschikbaar"`.
    <tr><td><dfn typedef export lt=majorversion|major-version-string>major-version</dfn>
        <td> (string)
        <td> Version string van de vorm "v&bs<;MAJOR&bs>;"
    <tr><td><dfn typedef export lt=version|version-string>version</dfn>
        <td> (string)
        <td> Version string van de vorm "&bs<;MAJOR&bs>;.&bs<;MINOR&bs>;.&bs<;PATCH&bs>;" of "&bs<;MAJOR&bs>;.&bs<;MINOR&bs>;" (patch nummer is optioneel)
    <tr><td><dfn typedef export lt=contact|contactPoint>contact</dfn>
        <td> (object)
        <td> Contactgegevens. Een object met de volgende optionele velden:
            <ul dfn-type="attribute" dfn-for=contact noexport>
                * <dfn>name</dfn> (string) Naam van het contact
                * <dfn>email</dfn> (string) Email adres van het contact
            </ul>
</table>

<!--
 ██████  ██     ██    ███    ██    ██  ██████   ████████ ██        ███████   ██████
██    ██ ██     ██   ██ ██   ███   ██ ██    ██  ██       ██       ██     ██ ██    ██
██       ██     ██  ██   ██  ████  ██ ██        ██       ██       ██     ██ ██
██       █████████ ██     ██ ██ ██ ██ ██   ████ ██████   ██       ██     ██ ██   ████
██       ██     ██ █████████ ██  ████ ██    ██  ██       ██       ██     ██ ██    ██
██    ██ ██     ██ ██     ██ ██   ███ ██    ██  ██       ██       ██     ██ ██    ██
 ██████  ██     ██ ██     ██ ██    ██  ██████   ████████ ████████  ███████   ██████
-->
Changelog {#changelog}
==================================================
Dit is een chronologisch overzicht van aanpassingen aan de amsterdam-schema specificatie.
Uitsluitend normatieve aanpassingen aan de specificatie worden vermeld. Aanpassingen aan voorbeelden,
waarschuwingen of uitleg verschijnen dus niet in dit overzicht.

<!-- Allways move the lastchange tag to the latest entry, so the correct entry is linked at the top of the page. -->
<!-- Include short (one sentence) description, a motivation and bullet list of all changes made in each entry. -->
<!-- Update the version number in the metadata at the top and refer to it here. -->

[3.2.0] rowLevelAuth toegevoegd (2025-11-11) {#lastchange}
---------------------------------------------------
> **Doelstelling**<br/>
    Toevoegen van row level authorisatie aan tabel.

* [[#tabel-optional-fields]] uitgebreid met rowLevelAuth.
* [[#row_level_auth]] toegevoegd.

[3.1.0] LifecycleStatus toegevoegd (2025-04-03) {#20250403}
---------------------------------------------------
> **Doelstelling**<br/>
    Toevoegen van lifecycleStatus aan versie en tabel.

* [[#version-mandatory-fields]] uitgebreid met lifecycleStatus.
* [[#version-lifecycle-status]] toegevoegd.
* [[#tabel-mandatory-fields]] uitgebreid met lifecycleStatus.
* [[#table-lifecycle-status]] toegevoegd.

[3.0.0] Dataset versionering toegevoegd (2025-03-03) {#20250303}
---------------------------------------------------
> **Doelstelling**<br/>
    Toevoegen van versionering van datasets aan V3 van het Amsterdam Schema.

* [[#dataset-versioning]] van datasets gedocumenteerd.
* [[#dataset-version]] toegevoegd.
* [[#table-versioning]] van tabellen aangepast naar de nieuwe situatie

[2.4.0] Scopes documentatie toegevoegd (2025-02-04) {#20250204}
---------------------------------------------------
> **Doelstelling**<br/>
    Aparte scopes objecten die de authorisatie van datasets, tabellen en velden bepalen.

* [[#scopes]] gedocumenteerd.
* auth velden kunnen nu verwijzen naar een of meer scope files.

[2.3.0] filterAuth attribuut toegevoegd (2025-01-12) {#20250112}
------------------------------------------------
> **Doelstelling**<br/>
    Betere afscherming van velden bij speciale zoekacties.

* Het {{veld/filterAuth}} attribuut is toegevoegd.
* De [[#profielen]] zijn gedocumenteerd.

[2.2.0] dataclass attribuut toegevoegd (2023-01-12) {#20230112}
------------------------------------------------
> **Doelstelling**<br/>
    Uitzonderingsgronden WOO in lijn gebracht met versie van WOO die nu van kracht is.

* Het {{tabel/dataclass}} attribuut is toegevoegd.

[2.1.5] dataclass attribuut toegevoegd (2023-01-10) {#20230110}
------------------------------------------------
> **Doelstelling**<br/>
    Beschrijving en relatering van ongestructureerde data mogelijk maken.

* De opties in attribuut {{dataset/reasonsNonPublic}} aangepast.
* Verwijzing [[Woo|Wet Open Overheid]] geupdate.

[2.1.4] Publishers zijn zelfstandige objecten geworden (2022-12-21) {#20221221}
------------------------------------------------
> **Doelstelling**<br/>
    Publishers zijn zelfstandige objecten geworden.

* Het {{dataset/publisher}} attribuut is een ref geworden.
* Het [=publisher=] object is toegevoegd.

[2.1.3] Auth attribuut verplicht op dataset niveau (2022-04-13) {#20220413-2}
------------------------------------------------
> **Doelstelling**<br/>
    Alle datasets zijn openbaar tenzij obv de Wet Open Overheid.
    Maar om onbedoelde openbaarmaking te voorkomen, moet dit altijd expliciet
    ingevuld worden. Voor data die niet publiek is moet de uitzonderingsgrond worden vermeld.

* Het {{dataset/auth}} attribuut is verplicht gemaakt.
* Het dataset attribuut {{dataset/reasonsNonPublic}} is toegevoegd.
* Het tabel attribuut {{tabel/reasonsNonPublic}} is toegevoegd.
* Het veld attribuut  {{veld/reasonsNonPublic}} is toegevoegd.

[2.1.2] Auth attribuut niet toegestaan bij identifier en display velden (2022-04-13) {#20220413-1}
------------------------------------------------
> **Doelstelling**<br/>
    De velden waar naar verwezen wordt in {{schema/identifier}} en {{schema/display}} moeten zichtbaar zijn voor iedereen
    die toegang heeft tot de tabel. Deze velden mogen dus geen {{veld/auth}} bevatten.

* De velden waar naar verwezen wordt in de {{schema/identifier}} en {{schema/display}} attributen
    mogen geen {{veld/auth}} attribuut bevatten.

[2.1.1] Crs attribuut verplicht bij geometrie velden (2022-03-23) {#change20220323}
------------------------------------------------
> **Doelstelling**<br/>
    Het coordinaat referentie systeem van een dataset met geo data moet bekend zijn voor correct functioneren van
    doelsystemen.

* Het {{dataset/crs}} veld is verplicht geworden wanneer één of meerdere tabellen een [[#geometry]] veld bevatten.

[2.1.0] Dataset contact gegevens (2022-03-17) {#change20220317}
------------------------------------------------
> **Doelstelling**<br/>
    Meerdere aanpassingen aan dataset velden voor contactgegevens.
    Met als doel om alle teams en organisaties die een rol hebben bij het ontsluiten van een dataset
    te vermelden. Zodat vragen over de dataset aan de juiste personen gericht kunnen worden.

* Nieuw optioneel veld {{dataset/creator}} toegevoegd.
* Het veld {{dataset/publisher}} heeft geen constant waarde meer. En bevat nu de naam van het datateam dat de dataset ontsluit.
* Het veld {{dataset/contactPoint}} is nu optioneel en bevat een standaard waarde.


<!--
████████  ████ ████████  ██       ████  ███████   ██████   ████████     ███    ████████  ██     ██ ██    ██
██     ██  ██  ██     ██ ██        ██  ██     ██ ██    ██  ██     ██   ██ ██   ██     ██ ██     ██  ██  ██
██     ██  ██  ██     ██ ██        ██  ██     ██ ██        ██     ██  ██   ██  ██     ██ ██     ██   ████
████████   ██  ████████  ██        ██  ██     ██ ██   ████ ████████  ██     ██ ████████  █████████    ██
██     ██  ██  ██     ██ ██        ██  ██     ██ ██    ██  ██   ██   █████████ ██        ██     ██    ██
██     ██  ██  ██     ██ ██        ██  ██     ██ ██    ██  ██    ██  ██     ██ ██        ██     ██    ██
████████  ████ ████████  ████████ ████  ███████   ██████   ██     ██ ██     ██ ██        ██     ██    ██
-->
<pre class=biblio>
    {
        "json-schema": {
            "href": "https://json-schema.org/draft/2020-12/json-schema-core.html",
            "title": "JSON Schema"
        },
        "json-schema-validation": {
            "href": "https://json-schema.org/draft/2020-12/json-schema-validation.html",
            "title": "JSON Schema"
        },
        "json-schema-string":{
            "href": "https://json-schema.org/understanding-json-schema/reference/string.html",
            "title":"JSON Schema string"
        },
        "semver": {
            "href": "https://semver.org/",
            "title": "SemVer"
        },
        "schemver": {
            "href": "https://snowplowanalytics.com/blog/2014/05/13/introducing-schemaver-for-semantic-versioning-of-schemas/",
            "title": "SchemaVer"
        },
        "ucum": {
          "href": "https://unitsofmeasure.org/ucum.html",
          "title": "The Unified Code for Units of Measure"
        },
        "rest-api-design-rules": {
            "href": "https://publicatie.centrumvoorstandaarden.nl/api/adr/",
            "title": "REST-API Design Rules"
        },
        "sdw-bp": {
            "href": "https://www.w3.org/TR/sdw-bp/",
            "title": "SDOW best practices"
        },
        "IEEE754": {
            "href":"https://datatracker.ietf.org/doc/html/rfc7159#ref-IEEE754",
            "title":"IEEE754"
        },
        "rfc7159": {
            "href":"https://datatracker.ietf.org/doc/html/rfc7159",
            "title":"RFC7159"
        },
        "ISO8601": {
            "href":"https://www.iso.org/iso-8601-date-and-time-format.html",
            "title":"ISO8601"
        },
        "Woo": {
            "href":"https://wetten.overheid.nl/BWBR0045754/2022-08-01",
            "title":"Wet open overheid"
        }
    }
</pre>

<!-- Force bib entries that are only deep referenced to appear in bibliography, this is a workaround for a bug in bikeshed -->
<div style="display:none">
    [[!json-schema-validation inline | ]]  [[SDW-BP inline | ]] [[REST-API-DESIGN-RULES]] [[RFC7159]] [[json-schema-string]]
</div>


<style>
    p[data-fill-with="logo"] {
        width: 180px;
        height: 180px;
        float: right;
        background-repeat: no-repeat;
        background-size: contain;
        background-image: url("https://api.data.amsterdam.nl/api/gemeente_Amsterdam_logo.svg");  /* Using [LOGO] here fails on Bikeshed 4 */
    }
    #toc::before {
        content: "Amsterdam Schema Specificatie";  /* Using [TITLE] here fails on Bikeshed 4 */
        background: rgb(0, 90, 156);
        color: var(--tocsidebar-bg);
        font-size: 18px;
        text-orientation: inherit;
        /* once because Chrome has shitty writing-mode support */
        writing-mode: vertical-lr;
        /* once more for Firefox */
        writing-mode: sideways-lr;
        position: fixed;
        padding-left: 3px;
        padding-bottom: 50px;
        padding-top: 50px;
        left: 0;
        top: 0;
        height: max-content;
    }
    dfn.idl-code code {
       font-size: initial;
       background: none !important;
       font-weight: bolder;
       line-height: 24px;
       font-family: sans-serif;
       padding: 0;
        border-radius: 0;
        display: inline-block;
    }
    .idl-code code c-[kc],
    .idl-code code c-[kr] {
        color: black;
        font-family: sans-serif;
    }

    .best-practice {
        border-color: blue;
        background: rgba(0,0,255,.05);
    }
    .dfn-table, .lst-table {
        width: 100%;
        width: -moz-available;
        width: -webkit-fill-available;
        width: stretch;
    }

    .dfn-table td {
        vertical-align: top;
        padding: .5em;
    }
    .dfn-table td:first-child {
        min-width: 150px;
    }

    .dfn-table tr:nth-child(even) {
        background: #F5F5F5;
    }

    .compare-code div {
        width: 50%;
        float: left;
        display: block;
        overflow: auto;
        padding: 0;
        margin: 0;
        text-align: center;
    }

    .compare-code div:first-child {
        width:calc(50% - 2px);
        margin-right: 2px;
    }

    .compare-code pre {
        width: max-content;
        padding: 0 ! important;
        min-width: 100%;
    }

    .compare-code .line.highlight-line {
        transition-property: background;
        transition-duration: 50ms;
    }

    .compare-code:hover .line.highlight-line {
        background: #0A84FF2B;
    }

    .compare-code .line-no.highlight-line[data-line]::before,
    .compare-code .line-no[data-line]::before,
    .compare-code .line-no.highlight-line {
        background: blue;
        padding: 0.1em;
        content: none;
    }

    /* Fix background of code inside an example */
    pre.highlight:not(.idl) {
        background: #eee !important;
    }

    .unhide-lines .line-no.highlight-line,
    .unhide-lines .line-no.highlight-line[data-line]::before,
    .unhide-lines .line-no[data-line]::before,
    .hide-lines .line-no.highlight-line[data-line]::before,
    .hide-lines .line-no[data-line]::before,
    .hide-lines .line-no.highlight-line {
        padding: 0.1em;
        content: none !important;
    }

    .hide-lines .line:not(.highlight-line), .hide-lines .line-no:not(.highlight-line) {
        height: 0;
        overflow: hidden;
        font-size: 0;
    }

    .hide-lines .line.highlight-line + .line-no:not(.highlight-line) + .line::before {
        content: "...";
        font-size: initial;
        margin-left: 25px;
    }

    .hide-lines .line.highlight-line + .line-no:not(.highlight-line),
    .hide-lines .line.highlight-line + .line-no:not(.highlight-line) + .line {
        height: initial;
        background: var(--highlight-hover-bg);
    }
    .unhide-lines pre ,
    .hide-lines pre {
        cursor: pointer;
    }
</style>
